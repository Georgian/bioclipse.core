<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;4.&nbsp;Packaging and Deploying Spring-based OSGi applications</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><link rel="start" href="index.html" title="Spring Dynamic Modules Reference Guide"><link rel="up" href="reference.html" title="Part&nbsp;II.&nbsp;Reference Documentation"><link rel="prev" href="bnd-app-ctx.html" title="Chapter&nbsp;3.&nbsp;Bundles and Application Contexts"><link rel="next" href="service-registry.html" title="Chapter&nbsp;5.&nbsp;The Service Registry"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns:fo="http://www.w3.org/1999/XSL/Format" style="background-color:white;border:none;height:73px;border:1px solid black;"><a style="border:none;" href="http://www.springframework.org/osgi/" title="The Spring Framework - Spring Dynamic Modules"><img style="border:none;" src="images/xdev-spring_logo.jpg"></a><a style="border:none;" href="http://www.SpringSource.com/" title="SpringSource - Spring from the Source"><img style="border:none;position:absolute;padding-top:5px;right:42px;" src="images/s2-banner-rhs.png"></a></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="app-deploy"></a>Chapter&nbsp;4.&nbsp;Packaging and Deploying Spring-based OSGi applications</h2></div></div></div><p>A traditional Spring application uses either a single application
    context, or a parent context containing service layer, data layer, and
    domain objects with a child context containing web layer components. The
    application context may well be formed by aggregating the contents of
    multiple configuration files.</p><p>When deploying an application to OSGi the more natural structure is
    to package the application as a set of peer bundles (application contexts)
    interacting via the OSGi service registry. Independent subsystems should
    be packaged as independent bundles or sets of bundles (vertical
    partitioning). A subsystem may be package in a single bundle, or divided
    into several bundles partitioned by layer (horizontal partitioning). A
    straightforward web application may for example be divided into four
    modules (bundles): a web bundle, service layer bundle, data layer bundle,
    and domain model bundle. Such an application would look like this:</p><div class="mediaobject" align="center"><img src="images/spring-osgi-model.png" align="middle" alt="Bundles and Application Contexts"></div><p>In this example the data layer bundle yields a data layer
    application context that contains a number of internal components (beans).
    Two of those beans are made publicly available outside of the application
    context by publishing them as services in the OSGi service
    registry.</p><p>The service layer bundle yields a service layer application context
    that contains a number of internal components (beans). Some of those
    components depend on data layer services, and import those services from
    the OSGi service registry. Two of the service layer components are made
    externally available as services in the OSGi service registry.</p><p>The web component bundle yields a web application context that
    contains a number of internal components (beans). Some of those components
    depend on application services, and import those services from the OSGi
    service registry. Since the domain model bundle contributes only domain
    model types, but does not need to create any components of its own, it has
    no associated application context.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="app-deploy:headers"></a>4.1.&nbsp;Bundle format and Manifest headers</h2></div></div></div><p>Each application module should be packaged as an OSGi bundle. A
      bundle is essentially a jar file with a
      <code class="literal">META-INF/MANIFEST.MF</code> file containing a series of
      headers recognized by the OSGi Service Platform. See the OSGi Service
      Platform Core Specification section 3.2 for details. Some OSGi
      implementations may support exploded jar files, but the format remains
      the same.</p><p>The Spring extender recognizes a bundle as "Spring-powered" and
      will create an associated application context when the bundle is started
      and one or both of the following conditions is true:</p><div class="itemizedlist"><ul type="disc"><li><p>The bundle path contains a folder
          <code class="literal">META-INF/spring</code> with one or more files in that
          folder with a '.xml' extension.</p></li><li><p><code class="literal">META-INF/MANIFEST.MF</code> contains a manifest
          header <code class="literal">Spring-Context</code>.</p></li></ul></div><p>In addition, if the optional
      <code class="literal">SpringExtender-Version</code> header is declared in the
      bundle manifest, then the extender will only recognize bundles where the
      specified version constraints are satisfied by the version of the
      extender bundle (<code class="literal">Bundle-Version</code>). The value of the
      <code class="literal">SpringExtender-Version</code> header must follow the syntax
      for a version range as specified in section 3.2.5 of the OSGi Service
      Platform Core Specification.</p><p>In the absence of the <code class="literal">Spring-Context</code> header the
      extender expects every ".xml" file in the
      <code class="literal">META-INF/spring</code> folder to be a valid Spring
      configuration file, and all directives (see below) take on their default
      values.</p><p>An application context is constructed from this set of files. A
      suggested practice is to split the application context configuration
      into at least two files, named by convention
      <span class="emphasis"><em>modulename</em></span>-context.xml and
      <span class="emphasis"><em>modulename</em></span>-osgi-context.xml. The
      <span class="emphasis"><em>modulename</em></span>-context.xml file contains regular bean
      definitions independent of any knowledge of OSGi. The
      <span class="emphasis"><em>modulename</em></span>-osgi-context.xml file contains the bean
      definitions for importing and exporting OSGi services. It may (but is
      not required to) use the Spring Dynamic Modules OSGi schema as the
      top-level namespace instead of the Spring 'beans' namespace.</p><p>The <code class="literal">Spring-Context</code> manifest header may be used
      to specify an alternate set of configuration files. The resource paths
      are treated as relative resource paths and resolve to entries defined in
      the bundle and the set of attached fragments. When the
      <code class="literal">Spring-Context</code> header defines at least one
      configuration file location, any files in
      <code class="literal">META-INF/spring</code> are ignored unless directly
      referenced from the <code class="literal">Spring-Context</code> header.</p><p>The syntax for the <code class="literal">Spring-Context</code> header value
      is:</p><pre class="programlisting">Spring-Context-Value ::= context ( ',' context ) *
context ::= path ( ';' path ) * (';' directive) *
</pre><p>This syntax is consistent with the OSGi Service Platform common
      header syntax defined in section 3.2.3 of the OSGi Service Platform Core
      Specification.</p><p>For example, the manifest entry:</p><pre class="programlisting">Spring-Context: config/account-data-context.xml, config/account-security-context.xml
</pre><p>will cause an application context to be instantiated using the
      configuration found in the files
      <code class="literal">account-data-context.xml</code> and
      <code class="literal">account-security-context.xml</code> in the bundle jar
      file.</p><p>A number of directives are available for use with the
      <code class="literal">Spring-Context</code> header. These directives are:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>create-asynchronously</em></span> (false|true):
          controls whether the application context is created asynchronously
          (the default), or synchronously.</p><p>For example:</p><pre class="programlisting">Spring-Context: *;create-asynchronously=false 
</pre><p>Creates an application context synchronously, using all of the
      "*.xml" files contained in the <code class="literal">META-INF/spring</code>
      folder.</p><pre class="programlisting">Spring-Context: config/account-data-context.xml;create-asynchrously:=false
</pre><p>Creates an application context synchronously using the
      <code class="literal">config/account-data-context.xml</code> configuration file.
      Care must be taken when specifying synchronous context creation as the
      application context will be created on the OSGi event thread, blocking
      further event delivery until the context is fully initialized. If an
      error occurs during the synchronous creation of the application context
      then a <code class="literal">FrameworkEvent.ERROR</code> event is raised. The bundle will still
      proceed to the <code class="literal">ACTIVE</code> state.</p></li><li><p><span class="emphasis"><em>wait-for-dependencies</em></span> (true|false):
          controls whether or not application context creation should wait for
          any mandatory service dependencies to be satisfied before proceeding
          (the default), or proceed immediately without waiting if
          dependencies are not satisfied upon startup.</p><p>For example:</p><pre class="programlisting">Spring-Context: config/osgi-*.xml;wait-for-dependencies:=false
</pre><p>Creates an application context using all the files matching
      "osgi-*.xml" in the config directory. Context creation will begin
      immediately even if dependencies are not satisfied. This essentially
      means that mandatory service references are treated as though they were
      optional - clients will be injected with a service object that may not
      be backed by an actual service in the registry initially. See section
      5.2 for more details.</p></li><li><p><span class="emphasis"><em>timeout</em></span> (300): the time to wait (in
          seconds) for mandatory dependencies to be satisfied before giving up
          and failing application context creation. This setting is ignored if
          <code class="literal">wait-for-dependencies:=false</code> is specified. The
          default is 5 minutes (300 seconds).</p><p>For example:</p><pre class="programlisting">Spring-Context: *;timeout:=60
</pre><p>Creates an application context that waits up to 1 minute (60 seconds)
	  for its mandatory dependencies to appear.
	  </p></li><li><p><span class="emphasis"><em>publish-context</em></span> (true|false): controls
          whether or not the application context object itself should be
          published in the OSGi service registry. The default is to publish
          the context.</p><p>For example:</p><pre class="programlisting">Spring-Context: *;publish-context:=false
</pre><p>If there is no Spring-Context manifest entry, or no value is
      specified for a given directive in that entry, then the directive takes
      on its default value.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d30e594"></a>4.2.&nbsp;Required Spring Framework and Spring Dynamic Modules
      Bundles</h2></div></div></div><p>The Spring Dynamic Modules project provides an number of bundle
      artifacts that must be installed in your OSGi platform in order for the
      Spring extender to function correctly:</p><div class="itemizedlist"><ul type="disc"><li><p>The extender bundle itself,
          <code class="literal">org.springframework.osgi.extender</code></p></li><li><p>The core implementation bundle for the Spring Dynamic Modules
          support, <code class="literal">org.springframework.osgi.core</code></p></li><li><p>The Spring Dynamic Modules I/O support library bundle,
          <code class="literal">org.springframework.osgi.io</code></p></li></ul></div><p>In addition the Spring Framework provides a number of bundles that
      are required to be installed. As of release 2.5 of the Spring Framework,
      the Spring jars included in the Spring distribution are valid OSGi
      bundles and can be installed directly into an OSGi platform. The minimum
      required set of bundles is:</p><div class="itemizedlist"><ul type="disc"><li><p>spring-core.jar (bundle symbolic name
          <code class="literal">org.springframework.bundle.spring.core</code>)</p></li><li><p>spring-context.jar (bundle symbolic name
          <code class="literal">org.springframework.bundle.spring.context</code>)</p></li><li><p>spring-beans.jar (bundle symbolic name
          <code class="literal">org.springframework.bundle.spring.beans</code>)</p></li><li><p>spring-aop.jar (bundle symbolic name
          <code class="literal">org.springframework.bundle.spring.aop</code>)</p></li></ul></div><p>In additional the following supporting library bundles are
      required. OSGi-ready versions of these libraries are shipped with the
      Spring Dynamic Modules distribution.</p><div class="itemizedlist"><ul type="disc"><li><p>aopalliance</p></li><li><p>backport-util (when running on JDK 1.4)</p></li><li><p>cglib-nodep (when proxying classes rather then
          interfaces, needed in most cases)</p></li><li><p>commons-logging API (SLF4J version highly recommended)</p></li><li><p>logging implementation such as log4j</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="app-deploy:spring-namespaces"></a>4.3.&nbsp;Spring XML authoring support</h2></div></div></div><p>Spring 2.0 introduced (among other things) <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springframework.org/spring/docs/2.5.x/reference/xsd-config.html" target="_top">
    	easier</a> XML configuration and <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springframework.org/spring/docs/2.5.x/reference/extensible-xml.html" target="_top">
    	extensible</a> XML authoring. The latter gives the ability of creating custom schemas that are discovered automatically (in non-OSGi environment)
    	by the Spring XML infrastructure by including them in the classpath. Spring-DM is aware of this process and supports it in OSGi environments so
    	that custom schemas are available to bundles that use them without any extra code or manifest declaration.</p><p>All bundles deployed in the OSGi space (whether they are <code class="literal">Spring-powered</code> or not) are scanned by Spring-DM for 
    	custom Spring namespace declaration (by checking the bundle space for<code class="literal">META-INF/spring.handlers</code> and 
    	<code class="literal">META-INF/spring.schemas</code>). If these are found, Spring-DM will make the schemas and the namespaces available through an OSGi
    	service that will be automatically used by Spring-powered bundles. This mean that if you deploy a bundle that uses a custom schema, all you have to do
    	is deploy the library that provides the namespace parser and the schema.
    	Bundles that embedded inside their classpath libraries that provide custom schemas will use these over those available in the OSGi space. However,
    	the namespaces of the embedded libraries will not shared with other bundles, that is, they will not be seen by any other bundle.</p><p>
    	In short, with using Spring-DM, custom Spring namespaces are supported transparently without any additional work. Embedded namespace providers will
    	have priority but will not be shared, as opposed to providers deployed as bundles which will be seen (and used) by others.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="app-deploy:imports-exports"></a>4.4.&nbsp;Importing and Exporting packages</h2></div></div></div><p>Refer to the OSGi Service Platform for details of the
      <code class="literal">Import-Package</code> and <code class="literal">Export-Package</code>
      manifest headers. Your bundle will need an
      <code class="literal">Import-Package</code> entry for every external package that
      the bundle depends on. If your bundle provides types that other bundles
      need access to, you will need <code class="literal">Export-Package</code> entries
      for every package that should be available from outside of the
      bundle.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="app-deploy:ext-libs"></a>4.5.&nbsp;Considerations when using external libraries</h2></div></div></div><div class="sidebar"><p class="title"><b>What is the context class loader?</b></p><p>
      	The thread context class loader was introduced in J2SE without much fanfare.
      	Below is a short definition for it, quoted from <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://java.sun.com/products/jndi/tutorial/beyond/misc/classloader.html" target="_top">one
      	</a> of the tutorials available on <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://java.sun.com/" target="_top">Java</a> site:
      	</p><p>
      	The Java 2 platform also introduced the notion of <span class="emphasis"><em>context class loader</em></span>. A thread's context class loader is, by default, 
      	set to the context class loader of the thread's parent. The hierarchy of threads is rooted at the primordial thread (the one that runs the program). 
      	The context class loader of the primordial thread is set to the class loader that loaded the application. So unless you explicitly change 
      	the thread's context class loader, its context class loader will be the application's class loader. That is, the context class loader can 
      	load the classes that the application can load. This loader is used by the Java runtime such as the RMI (Java Remote Method Invocation) to 
      	load classes and resources on behalf of the user application. The context class loader, like any Java 2 platform class loader, has a parent 
      	class loader and supports the same delegation model for class loading described previously.
      	</p></div><p>Many enterprise application libraries assume that all of the types
      and resources that comprise the application are accessible through the
      context class loader. While most developers do not use the context class 
      loader, the loader is used heavily by application servers, containers or 
      applications that are multi-threaded.</p><p>		      
      In OSGi R4, the set of types and resources
      available through the context class loader is undefined. 
      This means that the OSGi platform does not make a guarantee of the thread context 
      class loader value or in other words, it does not manage it.
      </p><p>
      Thus code (for example libraries) that performs manual class loading or that generates 
      new classes dynamically can cause problems when executed inside an OSGi environment.
      </p><p>Spring Dynamic Modules guarantees that during the creation of an
      application context on behalf of a given bundle, all of the types and
      resources on the bundle's classpath are accessible via the context class
      loader. Spring Dynamic Modules also allows you to control what is
      accessible through the context class loader when invoking external
      services and when servicing requests on exported services. See section 5
      for details on this.</p><p>Work is underway in the OSGi R5 timeframe to provide standardized
      support for dealing with generated classes and implicit class path
      dependencies introduced by third-party libraries. In the interim you may
      need to rely on workarounds such as the
      <code class="literal">DynamicImport-Package</code> manifest header, or the
      facilities provided by specific OSGi implementations such as Equinox's
      buddy mechanism. The Spring Dynamic Modules documentation contains more
      details on known issues with common enterprise libraries and the
      workarounds.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="app-deploy:troubleshooting"></a>4.6.&nbsp;Diagnosing problems</h2></div></div></div><p>Your chosen OSGi platform implementation should be able to provide
      you with a good deal of information about the current status of the OSGi
      environment. For example, starting Equinox with the
      <code class="literal">-console</code> argument provides a command-line console
      through which you can determine which bundles are installed and their
      states, the packages and services exported by bundles, find out why a
      bundle has failed to resolve, and drive bundles through the
      lifecycle.</p><p>In addition, Spring itself and the Spring Dynamic Modules bundles
      contain extensive logging instrumentation that can help you diagnose
      problems. The recommended approach is to deploy the Simple Logging
      Facade for Java (<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.slf4j.org/" target="_top">slf4j</a>)
      slf4j-api.jar and slf4j-log4j13.jar bundles (the jar files distributed
      by the project are valid OSGi bundles). Then you simply need to create a
      <code class="literal">log4j.properties</code> file in the root of your bundle
      classpath.</p><p>Note that Spring Dynamic Modules uses commons-logging API internally
      which means that its logging implementation is fully pluggable. Please see
      the FAQ and Resources pages for more information on other logging libraries
      besides log4j.
      </p></div></div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="bnd-app-ctx.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="service-registry.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;3.&nbsp;Bundles and Application Contexts&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:90%;"><a href="http://www.SpringSource.com/" title="SpringSource - Spring from the Source">Sponsored by SpringSource
                                        </a></span></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;5.&nbsp;The Service Registry</td></tr></table></div></body></html>