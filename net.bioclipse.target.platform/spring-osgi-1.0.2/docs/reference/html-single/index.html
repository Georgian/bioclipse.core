<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Spring Dynamic Modules Reference Guide</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d30e1"></a>Spring Dynamic Modules Reference Guide</h1></div><div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="authorgroup"><h2>Authors</h2><p></p><span class="author"><span class="firstname">Adrian M</span> <span class="surname">Colyer</span> 
            (SpringSource)
            </span>, <span class="author"><span class="firstname">Hal</span> <span class="surname">Hildebrand</span> 
            (Oracle)
            </span>, <span class="author"><span class="firstname">Costin</span> <span class="surname">Leau</span> 
            (SpringSource)
            </span>, <span class="author"><span class="firstname">Andy</span> <span class="surname">Piper</span> 
            (BEA)
            </span></div></div><div><p class="releaseinfo">1.0.2</p></div><div><div class="legalnotice"><a name="d30e39"></a><p>Copies of this document may be made for your own use and for
      distribution to others, provided that you do not charge any fee for such
      copies and further provided that each copy contains this Copyright
      Notice, whether distributed in print or electronically.</p></div></div></div><hr></div><div class="toc"><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="part"><a href="#introduction">I. Introduction</a></span></dt><dd><dl><dt><span class="chapter"><a href="#why-spring-dm">1. Why Spring Dynamic Modules?</a></span></dt><dt><span class="chapter"><a href="#requirements">2. Requirements</a></span></dt></dl></dd><dt><span class="part"><a href="#reference">II. Reference Documentation</a></span></dt><dd><dl><dt><span class="chapter"><a href="#bnd-app-ctx">3. Bundles and Application Contexts</a></span></dt><dd><dl><dt><span class="section"><a href="#bnd-app-ctx:extender">3.1. The Spring Dynamic Modules Extender bundle</a></span></dt><dt><span class="section"><a href="#bnd-app-ctx:app-creation">3.2. Application Context Creation</a></span></dt><dd><dl><dt><span class="section"><a href="#bnd-app-ctx:app-creation:mandatory-deps">3.2.1. Mandatory Service Dependencies</a></span></dt><dt><span class="section"><a href="#bnd-app-ctx:app-creation:app-ctx-publication">3.2.2. Application Context Service Publication</a></span></dt></dl></dd><dt><span class="section"><a href="#bnd-app-ctx:bnd-lifecycle">3.3. Bundle Lifecycle</a></span></dt><dt><span class="section"><a href="#bnd-app-ctx:osgi-resource">3.4. The Resource abstraction</a></span></dt><dt><span class="section"><a href="#bnd-app-ctx:access-bnd-ctx">3.5. Accessing the BundleContext</a></span></dt><dt><span class="section"><a href="#bnd-app-ctx:app-destruction">3.6. Application Context Destruction</a></span></dt><dt><span class="section"><a href="#bnd-app-ctx:access-bnd-ctx:stop-extender">3.7. Stopping the extender bundle</a></span></dt></dl></dd><dt><span class="chapter"><a href="#app-deploy">4. Packaging and Deploying Spring-based OSGi applications</a></span></dt><dd><dl><dt><span class="section"><a href="#app-deploy:headers">4.1. Bundle format and Manifest headers</a></span></dt><dt><span class="section"><a href="#d30e594">4.2. Required Spring Framework and Spring Dynamic Modules
      Bundles</a></span></dt><dt><span class="section"><a href="#app-deploy:spring-namespaces">4.3. Spring XML authoring support</a></span></dt><dt><span class="section"><a href="#app-deploy:imports-exports">4.4. Importing and Exporting packages</a></span></dt><dt><span class="section"><a href="#app-deploy:ext-libs">4.5. Considerations when using external libraries</a></span></dt><dt><span class="section"><a href="#app-deploy:troubleshooting">4.6. Diagnosing problems</a></span></dt></dl></dd><dt><span class="chapter"><a href="#service-registry">5. The Service Registry</a></span></dt><dd><dl><dt><span class="section"><a href="#service-registry:export">5.1. Exporting a Spring bean as an OSGi service</a></span></dt><dd><dl><dt><span class="section"><a href="#service-registry:export:intfs">5.1.1. Controlling the set of advertised service interfaces for
        an exported service</a></span></dt><dd><dl><dt><span class="section"><a href="#service-registry:export:auto-export">5.1.1.1. Detecting the advertised interfaces at runtime</a></span></dt></dl></dd><dt><span class="section"><a href="#service-registry:export:props">5.1.2. Controlling the set of advertised properties for an
        exported service</a></span></dt><dt><span class="section"><a href="#service-registry:export:depends-on">5.1.3. The depends-on attribute</a></span></dt><dt><span class="section"><a href="#service-registry:export:ccl">5.1.4. The context-class-loader attribute</a></span></dt><dt><span class="section"><a href="#service-registry:export:ranking">5.1.5. The ranking attribute</a></span></dt><dt><span class="section"><a href="#service-registry:export:service:attributes">5.1.6. <code class="literal">service</code> element attribute</a></span></dt><dt><span class="section"><a href="#service-registry:export:lifecycle">5.1.7. Service registration and unregistration lifecycle</a></span></dt><dd><dl><dt><span class="section"><a href="#service-registry:export:lifecycle:interface">5.1.7.1. Using <code class="interfacename">OsgiServiceRegistrationListener</code> interface</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#service-registry:refs">5.2. Defining references to OSGi services</a></span></dt><dd><dl><dt><span class="section"><a href="#service-registry:refs:singular">5.2.1. Referencing an individual service</a></span></dt><dd><dl><dt><span class="section"><a href="#service-registry:refs:singular:interface">5.2.1.1. Controlling the set of advertised interfaces for the imported service</a></span></dt><dt><span class="section"><a href="#service-registry:refs:singular:filter">5.2.1.2. The <code class="literal">filter</code> attribute</a></span></dt><dt><span class="section"><a href="#service-registry:refs:singular:bean-name">5.2.1.3. The <code class="literal">bean-name</code> attribute</a></span></dt><dt><span class="section"><a href="#service-registry:refs:singular:cardinality">5.2.1.4. The <code class="literal">cardinality</code> attribute</a></span></dt><dt><span class="section"><a href="#service-registry:refs:singular:depends-on">5.2.1.5. The depends-on attribute</a></span></dt><dt><span class="section"><a href="#service-registry:refs:singular:tccl">5.2.1.6. The context-class-loader attribute</a></span></dt><dt><span class="section"><a href="#service-registry:refs:singular:reference:attributes">5.2.1.7. <code class="literal">reference</code> element attributes</a></span></dt><dt><span class="section"><a href="#service-registry:refs:singular:dynamics">5.2.1.8. <code class="literal">reference</code> and OSGi Service Dynamics</a></span></dt><dt><span class="section"><a href="#service-registry:refs:singular:property-editor">5.2.1.9. Getting a hold of the managed service reference</a></span></dt></dl></dd><dt><span class="section"><a href="#service-registry:refs:collection">5.2.2. Referencing a collection of services</a></span></dt><dd><dl><dt><span class="section"><a href="#service-registry:refs:collection:attributes">5.2.2.1. Collection (<code class="literal">list</code> and <code class="literal">set</code>) element attributes</a></span></dt><dt><span class="section"><a href="#service-registry:refs:collection:dynamics">5.2.2.2. <code class="literal">list</code> / <code class="literal">set</code> and OSGi Service Dynamics</a></span></dt><dt><span class="section"><a href="#service-registry:refs:collection:iterator">5.2.2.3. <code class="interfacename">Iterator</code> contract and service collections</a></span></dt></dl></dd><dt><span class="section"><a href="#service-registry:refs:dynamics">5.2.3. Dealing with the dynamics of OSGi imported services</a></span></dt><dt><span class="section"><a href="#service-registry:refs:listener-and-proxies">5.2.4. Listener and service proxies</a></span></dt><dt><span class="section"><a href="#service-registry:refs:invoker-bundle-context">5.2.5. Accessing the caller <code class="interfacename">BundleContext</code></a></span></dt></dl></dd><dt><span class="section"><a href="#service-registry:refs:listener-best-practices">5.3. Exporter/Importer listener best practices</a></span></dt><dd><dl><dt><span class="section"><a href="#service-registry:refs:listener-best-practices:cycles">5.3.1. Listener and cyclic dependencies</a></span></dt></dl></dd><dt><span class="section"><a href="#service-registry:refs:global-defaults">5.4. Service importer global defaults</a></span></dt><dt><span class="section"><a href="#service-registry:export-import-relationship">5.5. Relationship between the service exporter and service importer</a></span></dt></dl></dd><dt><span class="chapter"><a href="#bundles">6. Working with Bundles</a></span></dt><dt><span class="chapter"><a href="#testing">7. Testing OSGi based Applications</a></span></dt><dd><dl><dt><span class="section"><a href="#testing:mocks">7.1. OSGi Mocks</a></span></dt><dt><span class="section"><a href="#testing:integration">7.2. Integration Testing</a></span></dt><dd><dl><dt><span class="section"><a href="#testing:integration:simple-test">7.2.1. Creating a simple OSGi integration test</a></span></dt><dt><span class="section"><a href="#testing:integration:provisioning">7.2.2. Installing test prerequisites</a></span></dt><dt><span class="section"><a href="#testing:integration:advanced-topics">7.2.3. Advanced testing framework topics</a></span></dt><dd><dl><dt><span class="section"><a href="#testing:integration:customize-manifest">7.2.3.1. Customizing the test manifest</a></span></dt><dt><span class="section"><a href="#testing:integration:specify-test-jar-content">7.2.3.2. Customizing test bundle content</a></span></dt><dt><span class="section"><a href="#testing:integration:understanding-manifest-creator">7.2.3.3. Understanding the <code class="code">MANIFEST.MF</code> generation</a></span></dt></dl></dd><dt><span class="section"><a href="#testing:integration:appContext">7.2.4. Creating an OSGi application context</a></span></dt><dt><span class="section"><a href="#testing:integration:specify-platform">7.2.5. Specifying the OSGi platform to use</a></span></dt><dt><span class="section"><a href="#testing:integration:specify-test-wait-time">7.2.6. Waiting for the test dependencies</a></span></dt><dt><span class="section"><a href="#testing:integration:performance">7.2.7. Testing framework performance</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="#appendixes">III. Appendixes</a></span></dt><dd><dl><dt><span class="appendix"><a href="#appendix-compendium">A. Compendium Services</a></span></dt><dd><dl><dt><span class="section"><a href="#compendium:cm">A.1.  Configuration Admin</a></span></dt><dd><dl><dt><span class="section"><a href="#compendium:cm:ppc">A.1.1. Property placeholder support</a></span></dt><dt><span class="section"><a href="#compendium:cm:dict">A.1.2. Configuration Dictionaries</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#appendix-extensions">B. Extensions</a></span></dt><dd><dl><dt><span class="section"><a href="#d30e3539">B.1. Annotation-based injection</a></span></dt></dl></dd><dt><span class="appendix"><a href="#appendix-pde-integration">C. Eclipse Plug-in Development integration</a></span></dt><dt><span class="appendix"><a href="#appendix-archetype">D. Spring Dynamic Modules Maven Archetype</a></span></dt><dd><dl><dt><span class="section"><a href="#archetype:generated-content">D.1. Generated Project Features at-a-glance</a></span></dt></dl></dd><dt><span class="appendix"><a href="#appendix-roadmap">E. Roadmap</a></span></dt><dd><dl><dt><span class="section"><a href="#d30e3807">E.1. Enhanced Configuration Admin Support</a></span></dt><dd><dl><dt><span class="section"><a href="#d30e3810">E.1.1. Managed Services</a></span></dt><dt><span class="section"><a href="#d30e3894">E.1.2. Managed Service Factories</a></span></dt><dt><span class="section"><a href="#d30e3959">E.1.3. Direct access to configuration data</a></span></dt><dt><span class="section"><a href="#d30e3980">E.1.4. Publishing configuration administration properties with
        exported services</a></span></dt></dl></dd><dt><span class="section"><a href="#d30e3994">E.2. Access to Service References for Collections</a></span></dt><dt><span class="section"><a href="#d30e4008">E.3. Start level integration</a></span></dt><dt><span class="section"><a href="#d30e4035">E.4. Web application support</a></span></dt><dt><span class="section"><a href="#d30e4049">E.5. ORM/Persistence support</a></span></dt><dt><span class="section"><a href="#d30e4062">E.6. OSGi standards</a></span></dt></dl></dd><dt><span class="appendix"><a href="#appendix-schema">F. Spring Dynamic Modules Schema</a></span></dt><dt><span class="appendix"><a href="#appendix-ack">G. Acknowledgments</a></span></dt></dl></dd><dt><span class="part"><a href="#resources">IV. Other Resources</a></span></dt><dd><dl><dt><span class="chapter"><a href="#links">8. Useful links</a></span></dt></dl></dd></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Preface</h2></div></div></div><p>
	Application development has seen significant changes in the last years, moving towards a simpler, more agile,
	POJO-based programming model in order to keep a fast pace. Dependency injection and Aspect Oriented Programming,
	which were once <span class="emphasis"><em>bleeding edge</em></span> ideas, are used on a daily basis by most developers to manage
	and simplify the complexity of their applications.</p><p>However, in terms of deployment, things have remained mainly unchanged. Even though code bases are divided into
	modules, whether logical, conceptual or physical, at runtime they are seen as one monolithic application in which,
	making a change (be it large or small), requires a restart. <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.osgi.org" target="_top">OSGi</a> aims
	to change this by allowing applications to be divided into <span class="emphasis"><em>modules</em></span> that can have different
	life cycles, dependencies and still exist as a whole.</p><p>Spring Dynamic Modules focuses on integrating Spring Framework powerful, non-invasive programming model and 
    concepts with the dynamics and modularity of OSGi platform. It allows transparent exporting and importing of OSGi
    services, life cycle management and control.</p><p>
	While every effort has been made to ensure that this documentation is comprehensive and there are no errors, 
	nevertheless some topics might require more explanation and some typos might have crept in. If you do spot any 
	mistakes or even more serious errors and you can spare a few cycles during lunch, please do bring the error 
	to the attention of the Spring Dynamic Modules team by raising an 
	<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://opensource.atlassian.com/projects/spring/browse/OSGI" target="_top">issue</a>. Thank you.
	</p></div><div class="part" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="introduction"></a>Part&nbsp;I.&nbsp;Introduction</h1></div></div></div><div class="partintro" lang="en"><div></div><p>
            </p><p>This document is the reference guide for Spring Dynamic Modules. It
			defines Spring Dynamic Modules concepts and semantics, the syntax for the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.osgi.org" target="_top">
			OSGi Service Platform</a> based namespaces, the Dynamic Modules extender bundle
			and the OSGi manifest header entries defined by Dynamic Modules. 
			For a tutorial introduction to building OSGi-based applications with Spring Dynamic 
			Modules see our online <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.springframework.org/osgi" target="_top">page</a>.</p><p>

			</p><p>OSGi developers looking for an introduction to Spring should review
			the introductory <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.springframework.org/documentation" target="_top">articles</a> 
			on the springframework.org site.</p><p>

			</p><p><span class="emphasis"><em>Note: OSGi is a trademark of the OSGi Alliance. Project
			name is pending final approval from the Alliance.</em></span></p><p>

			</p><p><span class="emphasis"><em>Note: Please see the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="./issues.html" target="_top">known
			issues</a> page for Spring Dynamic Modules  release.</em></span></p><p>
          </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="why-spring-dm"></a>Chapter&nbsp;1.&nbsp;Why Spring Dynamic Modules?</h2></div></div></div><p>The Spring Framework is the leading full-stack Java/JEE
    application framework. It provides a lightweight container and a
    non-invasive programming model enabled by the use of dependency
    injection, AOP, and portable service abstractions. The OSGi Service
    Platform offers a dynamic application execution environment in which
    modules (bundles) can be installed, updated, or removed on the fly. It
    also has excellent support for modularity and versioning.</p><p>Spring Dynamic Modules makes it easy to write Spring applications
    that can be deployed in an OSGi execution environment, and that can take
    advantage of the services offered by the OSGi framework. Spring's OSGi
    support also makes development of OSGi applications simpler and more
    productive by building on the ease-of-use and power of the Spring
    Framework. For enterprise applications, the combination of Spring
    Dynamic Modules and the OSGi platform provides:</p><div class="itemizedlist"><ul type="disc"><li><p>Better separation of application logic into modules, with
        runtime enforcement of module boundaries</p></li><li><p>The ability to deploy multiple versions of a module (or
        library) concurrently</p></li><li><p>The ability to dynamically discover and use services provided
        by other modules in the system</p></li><li><p>The ability to dynamically install, update and uninstall
        modules in a running system</p></li><li><p>Use of the Spring Framework to instantiate, configure,
        assemble, and decorate components within and across modules.</p></li><li><p>A simple and familiar programming model for enterprise
        developers to exploit the features of the OSGi platform.</p></li></ul></div><p>We believe that the combination of OSGi and Spring offers a
    comprehensive model for building enterprise applications.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="requirements"></a>Chapter&nbsp;2.&nbsp;Requirements</h2></div></div></div><p>Spring Dynamic Modules 1.0 supports JDK level 1.4 and above 
      and <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www2.osgi.org/Specifications/HomePage?section=2" target="_top">OSGi
      R4</a> and above. Bundles deployed for
      use with Spring Dynamic Modules should specify
      <code class="literal">"Bundle-ManifestVersion: 2"</code> in their manifest (OSGi R4). 
      We test against <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.eclipse.org/equinox/" target="_top">Equinox</a> 3.2.2, <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://felix.apache.org/" target="_top">Felix</a> 1.0.1, and <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.knopflerfish.org/" target="_top">Knopflerfish</a> 2.0.3 as part of our
      continuous integration process.</p></div></div><div class="part" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="reference"></a>Part&nbsp;II.&nbsp;Reference Documentation</h1></div></div></div><div class="partintro" lang="en"><div><div><div><h1 class="title"><a name="d30e149"></a>Document structure</h1></div></div></div><p>This part of the reference documentation explains the core functionality
	  offered by Spring Dynamic Modules.</p><p><a href="#bnd-app-ctx" title="Chapter&nbsp;3.&nbsp;Bundles and Application Contexts">Chapter&nbsp;3, <i xmlns:xlink="http://www.w3.org/1999/xlink">Bundles and Application Contexts</i></a> describes the relationship between an OSGi Bundle and a 
      Spring Application Context,
      and introduces the Spring Extender Bundle support for instantiating
      application contexts automatically.</p><p><a href="#app-deploy" title="Chapter&nbsp;4.&nbsp;Packaging and Deploying Spring-based OSGi applications">Chapter&nbsp;4, <i xmlns:xlink="http://www.w3.org/1999/xlink">Packaging and Deploying Spring-based OSGi applications</i></a> describes how to deploy the Spring Framework jar files in
      an OSGi environment, and how to reference external APIs from your
      application bundles should you need to do so. This chapter also explains
      some of the issues to be aware of when using existing enterprise
      libraries not designed for OSGi in an OSGi environment.</p><p><a href="#service-registry" title="Chapter&nbsp;5.&nbsp;The Service Registry">Chapter&nbsp;5, <i xmlns:xlink="http://www.w3.org/1999/xlink">The Service Registry</i></a> describes how to export Spring
      beans as services in the OSGi service registry, and how to inject
      references to OSGi services into beans. This chapter also defines how
      the dynamic life-cycle of OSGi services and bundles is supported.</p><p><a href="#bundles" title="Chapter&nbsp;6.&nbsp;Working with Bundles">Chapter&nbsp;6, <i xmlns:xlink="http://www.w3.org/1999/xlink">Working with Bundles</i></a> describes how to declare a bean
      that represents an OSGi bundle, including support for installing new
      bundles into the OSGi platform.</p><p><a href="#testing" title="Chapter&nbsp;7.&nbsp;Testing OSGi based Applications">Chapter&nbsp;7, <i xmlns:xlink="http://www.w3.org/1999/xlink">Testing OSGi based Applications</i></a> explains the
      integration testing support provided by Spring Dynamic Modules. This
      support enables you to write simple JUnit integration tests that can
      start up an OSGi environment, install the bundles needed for the
      integration test, execute the test case(s) inside of OSGi, and return
      the results to the runner. This makes it easy to integrate OSGi
      integration testing into any environment that can work with
      JUnit.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="bnd-app-ctx"></a>Chapter&nbsp;3.&nbsp;Bundles and Application Contexts</h2></div></div></div><p>The unit of deployment (and modularity) in OSGi is the <span class="emphasis"><em>bundle</em></span> (see
    section 3.2 of the OSGi Service Platform Core Specification). A bundle
    known to the OSGi runtime is in one of three steady states: installed,
    resolved, or active. Bundles may export services (objects) to the OSGi
    service registry, and by so doing make these services available for other
    bundles to discover and to use. Bundles may also export Java packages,
    enabling other bundles to import the exported types.</p><p>In Spring the primary unit of modularity is an <span class="emphasis"><em>application context</em></span>,
    which contains some number of beans (objects managed by the Spring
    application context). Application contexts can be configured in a
    hierarchy such that a child application context can see beans defined in a
    parent, but not vice-versa. The Spring concepts of exporters and factory
    beans are used to export references to beans to clients outside of the
    application context, and to inject references to services that are defined
    outside of the application context.</p><p>There is a natural affinity between an OSGi bundle and a Spring
    application context. Using Spring Dynamic Modules, an active bundle may
    contain a Spring application context, responsible for the instantiation,
    configuration, assembly, and decoration of the objects (beans) within the
    bundle. Some of these beans may optionally be exported as OSGi services
    and thus made available to other bundles, beans within the bundle may also
    be transparently injected with references to OSGi services.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="bnd-app-ctx:extender"></a>3.1.&nbsp;The Spring Dynamic Modules Extender bundle</h2></div></div></div><p>Spring Dynamic Modules provides an OSGi bundle
      <code class="literal">org.springframework.bundle.osgi.extender</code>. This
      bundle is responsible for instantiating the Spring application contexts
      for your application bundles. It serves the same purpose as the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springframework.org/spring/docs/2.5.x/reference/webintegration.html" target="_top">ContextLoaderListener</a>
      does for Spring web applications. Once the extender bundle is installed
      and started it looks for any existing Spring-powered bundles that are
      already in the <span class="emphasis"><em>ACTIVE</em></span> state and creates application contexts on their
      behalf. In addition, it listens for bundle starting events and
      automatically creates an application context for any Spring-powered
      bundle that is subsequently started. <a href="#app-deploy:headers" title="4.1.&nbsp;Bundle format and Manifest headers">Section&nbsp;4.1, &#8220;Bundle format and Manifest headers&#8221;</a>
      describes what the extender recognizes as a "Spring-powered bundle".</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="bnd-app-ctx:app-creation"></a>3.2.&nbsp;Application Context Creation</h2></div></div></div><p>The extender bundle creates applications contexts asynchronously.
      This behaviour ensures that starting an OSGi Service Platform is fast and
      that bundles with service inter-dependencies do not cause deadlock on
      startup. A Spring-powered bundle may therefore transition to the STARTED
      state before its application context has been created. It is possible to
      force synchronous creation of application contexts on a bundle-by-bundle
      basis. See <a href="#app-deploy:headers" title="4.1.&nbsp;Bundle format and Manifest headers">Section&nbsp;4.1, &#8220;Bundle format and Manifest headers&#8221;</a> for information on how to specify this
      behaviour.</p><p>If application context creation fails for any reason then the
      failure cause is logged. The bundle remains in the STARTED state. There
      will be no services exported to the registry from the application
      context in this scenario.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="bnd-app-ctx:app-creation:mandatory-deps"></a>3.2.1.&nbsp;Mandatory Service Dependencies</h3></div></div></div><p>If an application context declares mandatory dependencies on the
        availability of certain OSGi services (see <a href="#service-registry" title="Chapter&nbsp;5.&nbsp;The Service Registry">Chapter&nbsp;5, <i xmlns:xlink="http://www.w3.org/1999/xlink">The Service Registry</i></a>) then creation
        of the application context is blocked until all mandatory dependencies
        can be satisfied through matching services available in the OSGi
        service registry. Since a service may come and go at any moment in an
        OSGi environment, this behaviour only guarantees that all mandatory
        services were available at the moment creation of the application
        context began. One or more services may subsequently become
        unavailable again during the process of application context creation.
        <a href="#service-registry" title="Chapter&nbsp;5.&nbsp;The Service Registry">Chapter&nbsp;5, <i xmlns:xlink="http://www.w3.org/1999/xlink">The Service Registry</i></a> describes what happens when a mandatory service reference
        becomes unsatisfied. In practice, for most enterprise applications
        built using Spring Dynamic Modules services, the set of available
        services and bundles will reach a steady state once the platform and
        its installed bundles are all started. In such a world the behaviour of
        waiting for mandatory dependencies simply ensures that bundles A and
        B, where bundle A depends on services exported by bundle B, may be
        started in any order.</p><p>A timeout applies to the wait for mandatory dependencies to be
        satisfied. By default the timeout is set to 5 minutes, but this value
        can be configured using the <code class="literal">timeout</code> directive. See
        <a href="#app-deploy:headers" title="4.1.&nbsp;Bundle format and Manifest headers">Section&nbsp;4.1, &#8220;Bundle format and Manifest headers&#8221;</a> for details.</p><p>It is possible to change the application context creation
        semantics so that application context creation fails if all mandatory
        services are not immediately available upon startup (see section 4.1).
        When configured to not wait for dependencies, a bundle with
        unsatisfied mandatory dependencies will be stopped, leaving the bundle
        in the <span class="emphasis"><em>RESOLVED</em></span> state.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="bnd-app-ctx:app-creation:app-ctx-publication"></a>3.2.2.&nbsp;Application Context Service Publication</h3></div></div></div><p>Once the application context creation for a bundle has
        completed, the application context object is automatically exported as
        a service available through the OSGi Service Registry. The context is
        published under the interface
        <code class="interfacename">org.springframework.context.ApplicationContext</code> (and
        also all of the visible super-interfaces and types implemented by the
        context). The published service has a service property named
        <code class="literal">org.springframework.context.service.name</code> whose
        value is set to the bundle symbolic name of the bundle hosting the
        application context. It is possible to prevent publication of the
        application context as a service using a directive in the bundle's
        manifest. See <a href="#app-deploy:headers" title="4.1.&nbsp;Bundle format and Manifest headers">Section&nbsp;4.1, &#8220;Bundle format and Manifest headers&#8221;</a> for details.</p><p>Note: the application context is published as a service
        primarily to facilitate testing, administration, and management.
        Accessing this context object at runtime and invoking
        <code class="literal">getBean()</code> or similar operations is discouraged. The
        preferred way to access a bean defined in another application context
        is to export that bean as an OSGi service from the defining context,
        and then to import a reference to that service in the context that
        needs access to the service. Going via the service registry in this
        way ensures that a bean only sees services with compatible versions of
        service types, and that OSGi platform dynamics are respected.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="bnd-app-ctx:bnd-lifecycle"></a>3.3.&nbsp;Bundle Lifecycle</h2></div></div></div><p>OSGi is a dynamic platform: bundles may be installed, started,
      updated, stopped, and uninstalled at any time during the running of the
      framework.</p><p>When an active bundle is stopped, any services it exported during
      its lifetime are automatically unregistered and the bundle returns to
      the resolved state. A stopped bundle should release any resources it has
      acquired and terminate any threads. Packages exported by a stopped
      bundle continue to be available to other bundles.</p><p>A bundle in the resolved state may be uninstalled: packages that
      were exported by an uninstalled bundle continue to be available to
      bundles that imported them (but not to newly installed bundles).</p><p>A bundle in the resolved state may also be updated. The update
      process migrates from one version of a bundle to another version of the
      same bundle.</p><p>Finally of course, a resolved bundle can be started, which
      transitions it to the active state.</p><p>The OSGi <code class="literal">PackageAdmin</code>
      <code class="literal">refreshPackages</code> operation refreshes packages across
      the whole OSGi framework or a given subset of installed bundles. During
      the refresh, an application context in an affected bundle will be
      stopped and restarted. After a <code class="literal">refreshPackages</code>
      operation, packages exported by older versions of updated bundles, or
      packages exported by uninstalled bundles, are no longer available.
      Consult the OSGi specifications for full details.</p><p>When a Spring-powered bundle is stopped, the application context
      created for it is automatically destroyed. All services exported by the
      bundle will be unregistered (removed from the service registry) and the
      normal application context tear-down life-cycle is observed
      (<code class="interfacename">org.springframework.beans.factory.DisposableBean</code> implementors 
      and <code class="literal">destroy-method</code>
      callbacks are invoked on beans in the context).</p><p>If a Spring-powered bundle that has been stopped is subsequently
      re-started, a new application context will be created for it.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="bnd-app-ctx:osgi-resource"></a>3.4.&nbsp;The Resource abstraction</h2></div></div></div><p>The Spring Framework defines a resource abstraction for loading
      resources within an application context (see <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springframework.org/spring/docs/2.5.x/reference/resources.html" target="_top">Spring's
      resource abstraction</a>). All resource loading is done through the
      <code class="interfacename">org.springframework.core.io.ResourceLoader</code> associated with the application
      context. The <code class="interfacename">org.springframework.core.io.ResourceLoader</code> is also 
      available to beans wishing to load resources programmatically. Resource paths with
      explicit prefixes - for example "classpath:" are treated uniformly
      across all application context types (for example, web application
      contexts and classpath-based application contexts). Relative resource
      paths are interpreted differently based on the kind of application
      context being created. This enables easy integration testing outside
      the ultimate deployment environment.</p><p>OSGi 4.0.x specification defines three different spaces from which a
	  resource can be loaded. Spring-DM supports all of them through its dedicated OSGi-specific
	  application context and dedicated prefixes:</p><div class="table"><a name="osgi-search-strategies"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;OSGi resource search strategies</b></p><div class="table-contents"><table summary="OSGi resource search strategies" width="100%" border="1"><colgroup><col align="left"><col><col></colgroup><thead><tr><th align="left">OSGi search strategy</th><th>prefix</th><th>Explanation</th></tr></thead><tbody><tr><td align="left">Class Space</td><td><code class="literal">classpath:</code></td><td>Search the bundle classloader (the bundle and all imported packages). Forces the bundle to be resolved.</td></tr><tr><td align="left">JAR File (or JarSpace)</td><td><code class="literal">osgibundlejar:</code></td><td>Search only the bundle jar. Provides low-level access without requiring the bundle to be resolved.</td></tr><tr><td align="left">Bundle Space</td><td><code class="literal">osgibundle:</code></td><td>Search the bundle jar and its attached fragments (if there are any). Will never create a class loader or resolve the bundle.</td></tr></tbody></table></div></div><br class="table-break"><p>Please consult section 4.3.12 of the OSGi specification for an in depth explanation of the differences between them.
	  </p><p>
	  Note that if no prefix is specified, the bundle space will be used. 
	  </p><p>All of the regular Spring resource prefixes such as <code class="literal">file:</code> and
      <code class="literal">http:</code> are also supported, as are the pattern matching wildcards.
      Resources loaded using such prefixes may come from any location, they
      are not restricted to being defined within the resource-loading bundle
      or its attached fragments.</p><p>OSGi platforms may define their own unique prefixes for accessing
      bundle contents. For example, Equinox defines the <code class="literal">bundleresource:</code> and
      <code class="literal">bundlentry:</code> prefixes). These platform specific prefixes may also be
      used with Spring OSGi, at the cost of course of tying yourself to a
      particular OSGi implementation.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="bnd-app-ctx:access-bnd-ctx"></a>3.5.&nbsp;Accessing the BundleContext</h2></div></div></div><p>In general there is no need to depend on any OSGi APIs when using
      the Spring Dynamic Modules support. If you <span class="emphasis"><em>do</em></span> need
      access to the OSGi <code class="interfacename">BundleContext</code> object for your
      bundle, then Spring makes this easy to do.</p><p>The OSGi application context created by the Spring extender will
      automatically contain a bean of type <code class="interfacename">BundleContext</code>
      and with name <code class="literal">bundleContext</code>. You can inject a
      reference to this bean into any bean in the application context either
      by-name or by-type. In addition, Spring Dynamic Modules defines the
      interface
      <code class="interfacename">org.springframework.osgi.context.BundleContextAware</code>:</p><pre class="programlisting">public interface BundleContextAware {
  public void setBundleContext(BundleContext context);
}</pre><p>Any bean implementing this interface will be injected with a
      reference to the bundle context when it is configured by Spring. If you
      wish to use this facility within a bundle, remember to import the
      package <code class="literal">org.springframework.osgi.context</code> in your
      bundle manifest.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="bnd-app-ctx:app-destruction"></a>3.6.&nbsp;Application Context Destruction</h2></div></div></div><p>The application context is bound to the bundle in which it lives. Thus, if the declaring 
      bundle is being shutdown, the application context will be destroyed as well,
      all exported services being unregistered and all service imported dispose of.
      </p><p>Note however that a bundle can be closed individually or as part of a bigger
      event such as shutting down the entire OSGi platform. In this case or when the extender
      bundle is being closed down, the managed application contexts will be closed in a managed
      manner based on the service dependencies between them. Please see the next section for more
      details.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="bnd-app-ctx:access-bnd-ctx:stop-extender"></a>3.7.&nbsp;Stopping the extender bundle</h2></div></div></div><p>If the extender bundle is stopped, then all the application
      contexts created by the extender will be destroyed. Application contexts
      are shutdown in the following order:</p><div class="orderedlist"><ol type="1"><li><p>Application contexts that do not export any services, or that
          export services that are not currently referenced, are shutdown in
          reverse order of bundle id. (Most recently installed bundles have
          their application contexts shutdown first).</p></li><li><p>Shutting down the application contexts in step (1) may have
          released references these contexts were holding such that there are
          now additional application contexts that can be shutdown. If so,
          repeat step 1 again.</p></li><li><p>If there are no more active application contexts, we have
          finished. If there <span class="emphasis"><em>are</em></span> active application
          contexts then there must be a cyclic dependency of references. The
          circle is broken by determining the highest ranking service exported
          by each context: the bundle with the lowest ranking service in this
          set (or in the event of a tie, the highest service id), is shut
          down. Repeat from step (1).</p></li></ol></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="app-deploy"></a>Chapter&nbsp;4.&nbsp;Packaging and Deploying Spring-based OSGi applications</h2></div></div></div><p>A traditional Spring application uses either a single application
    context, or a parent context containing service layer, data layer, and
    domain objects with a child context containing web layer components. The
    application context may well be formed by aggregating the contents of
    multiple configuration files.</p><p>When deploying an application to OSGi the more natural structure is
    to package the application as a set of peer bundles (application contexts)
    interacting via the OSGi service registry. Independent subsystems should
    be packaged as independent bundles or sets of bundles (vertical
    partitioning). A subsystem may be package in a single bundle, or divided
    into several bundles partitioned by layer (horizontal partitioning). A
    straightforward web application may for example be divided into four
    modules (bundles): a web bundle, service layer bundle, data layer bundle,
    and domain model bundle. Such an application would look like this:</p><div class="mediaobject" align="center"><img src="images/spring-osgi-model.png" align="middle" alt="Bundles and Application Contexts"></div><p>In this example the data layer bundle yields a data layer
    application context that contains a number of internal components (beans).
    Two of those beans are made publicly available outside of the application
    context by publishing them as services in the OSGi service
    registry.</p><p>The service layer bundle yields a service layer application context
    that contains a number of internal components (beans). Some of those
    components depend on data layer services, and import those services from
    the OSGi service registry. Two of the service layer components are made
    externally available as services in the OSGi service registry.</p><p>The web component bundle yields a web application context that
    contains a number of internal components (beans). Some of those components
    depend on application services, and import those services from the OSGi
    service registry. Since the domain model bundle contributes only domain
    model types, but does not need to create any components of its own, it has
    no associated application context.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="app-deploy:headers"></a>4.1.&nbsp;Bundle format and Manifest headers</h2></div></div></div><p>Each application module should be packaged as an OSGi bundle. A
      bundle is essentially a jar file with a
      <code class="literal">META-INF/MANIFEST.MF</code> file containing a series of
      headers recognized by the OSGi Service Platform. See the OSGi Service
      Platform Core Specification section 3.2 for details. Some OSGi
      implementations may support exploded jar files, but the format remains
      the same.</p><p>The Spring extender recognizes a bundle as "Spring-powered" and
      will create an associated application context when the bundle is started
      and one or both of the following conditions is true:</p><div class="itemizedlist"><ul type="disc"><li><p>The bundle path contains a folder
          <code class="literal">META-INF/spring</code> with one or more files in that
          folder with a '.xml' extension.</p></li><li><p><code class="literal">META-INF/MANIFEST.MF</code> contains a manifest
          header <code class="literal">Spring-Context</code>.</p></li></ul></div><p>In addition, if the optional
      <code class="literal">SpringExtender-Version</code> header is declared in the
      bundle manifest, then the extender will only recognize bundles where the
      specified version constraints are satisfied by the version of the
      extender bundle (<code class="literal">Bundle-Version</code>). The value of the
      <code class="literal">SpringExtender-Version</code> header must follow the syntax
      for a version range as specified in section 3.2.5 of the OSGi Service
      Platform Core Specification.</p><p>In the absence of the <code class="literal">Spring-Context</code> header the
      extender expects every ".xml" file in the
      <code class="literal">META-INF/spring</code> folder to be a valid Spring
      configuration file, and all directives (see below) take on their default
      values.</p><p>An application context is constructed from this set of files. A
      suggested practice is to split the application context configuration
      into at least two files, named by convention
      <span class="emphasis"><em>modulename</em></span>-context.xml and
      <span class="emphasis"><em>modulename</em></span>-osgi-context.xml. The
      <span class="emphasis"><em>modulename</em></span>-context.xml file contains regular bean
      definitions independent of any knowledge of OSGi. The
      <span class="emphasis"><em>modulename</em></span>-osgi-context.xml file contains the bean
      definitions for importing and exporting OSGi services. It may (but is
      not required to) use the Spring Dynamic Modules OSGi schema as the
      top-level namespace instead of the Spring 'beans' namespace.</p><p>The <code class="literal">Spring-Context</code> manifest header may be used
      to specify an alternate set of configuration files. The resource paths
      are treated as relative resource paths and resolve to entries defined in
      the bundle and the set of attached fragments. When the
      <code class="literal">Spring-Context</code> header defines at least one
      configuration file location, any files in
      <code class="literal">META-INF/spring</code> are ignored unless directly
      referenced from the <code class="literal">Spring-Context</code> header.</p><p>The syntax for the <code class="literal">Spring-Context</code> header value
      is:</p><pre class="programlisting">Spring-Context-Value ::= context ( ',' context ) *
context ::= path ( ';' path ) * (';' directive) *
</pre><p>This syntax is consistent with the OSGi Service Platform common
      header syntax defined in section 3.2.3 of the OSGi Service Platform Core
      Specification.</p><p>For example, the manifest entry:</p><pre class="programlisting">Spring-Context: config/account-data-context.xml, config/account-security-context.xml
</pre><p>will cause an application context to be instantiated using the
      configuration found in the files
      <code class="literal">account-data-context.xml</code> and
      <code class="literal">account-security-context.xml</code> in the bundle jar
      file.</p><p>A number of directives are available for use with the
      <code class="literal">Spring-Context</code> header. These directives are:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>create-asynchronously</em></span> (false|true):
          controls whether the application context is created asynchronously
          (the default), or synchronously.</p><p>For example:</p><pre class="programlisting">Spring-Context: *;create-asynchronously=false 
</pre><p>Creates an application context synchronously, using all of the
      "*.xml" files contained in the <code class="literal">META-INF/spring</code>
      folder.</p><pre class="programlisting">Spring-Context: config/account-data-context.xml;create-asynchrously:=false
</pre><p>Creates an application context synchronously using the
      <code class="literal">config/account-data-context.xml</code> configuration file.
      Care must be taken when specifying synchronous context creation as the
      application context will be created on the OSGi event thread, blocking
      further event delivery until the context is fully initialized. If an
      error occurs during the synchronous creation of the application context
      then a <code class="literal">FrameworkEvent.ERROR</code> event is raised. The bundle will still
      proceed to the <code class="literal">ACTIVE</code> state.</p></li><li><p><span class="emphasis"><em>wait-for-dependencies</em></span> (true|false):
          controls whether or not application context creation should wait for
          any mandatory service dependencies to be satisfied before proceeding
          (the default), or proceed immediately without waiting if
          dependencies are not satisfied upon startup.</p><p>For example:</p><pre class="programlisting">Spring-Context: config/osgi-*.xml;wait-for-dependencies:=false
</pre><p>Creates an application context using all the files matching
      "osgi-*.xml" in the config directory. Context creation will begin
      immediately even if dependencies are not satisfied. This essentially
      means that mandatory service references are treated as though they were
      optional - clients will be injected with a service object that may not
      be backed by an actual service in the registry initially. See section
      5.2 for more details.</p></li><li><p><span class="emphasis"><em>timeout</em></span> (300): the time to wait (in
          seconds) for mandatory dependencies to be satisfied before giving up
          and failing application context creation. This setting is ignored if
          <code class="literal">wait-for-dependencies:=false</code> is specified. The
          default is 5 minutes (300 seconds).</p><p>For example:</p><pre class="programlisting">Spring-Context: *;timeout:=60
</pre><p>Creates an application context that waits up to 1 minute (60 seconds)
	  for its mandatory dependencies to appear.
	  </p></li><li><p><span class="emphasis"><em>publish-context</em></span> (true|false): controls
          whether or not the application context object itself should be
          published in the OSGi service registry. The default is to publish
          the context.</p><p>For example:</p><pre class="programlisting">Spring-Context: *;publish-context:=false
</pre><p>If there is no Spring-Context manifest entry, or no value is
      specified for a given directive in that entry, then the directive takes
      on its default value.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d30e594"></a>4.2.&nbsp;Required Spring Framework and Spring Dynamic Modules
      Bundles</h2></div></div></div><p>The Spring Dynamic Modules project provides an number of bundle
      artifacts that must be installed in your OSGi platform in order for the
      Spring extender to function correctly:</p><div class="itemizedlist"><ul type="disc"><li><p>The extender bundle itself,
          <code class="literal">org.springframework.osgi.extender</code></p></li><li><p>The core implementation bundle for the Spring Dynamic Modules
          support, <code class="literal">org.springframework.osgi.core</code></p></li><li><p>The Spring Dynamic Modules I/O support library bundle,
          <code class="literal">org.springframework.osgi.io</code></p></li></ul></div><p>In addition the Spring Framework provides a number of bundles that
      are required to be installed. As of release 2.5 of the Spring Framework,
      the Spring jars included in the Spring distribution are valid OSGi
      bundles and can be installed directly into an OSGi platform. The minimum
      required set of bundles is:</p><div class="itemizedlist"><ul type="disc"><li><p>spring-core.jar (bundle symbolic name
          <code class="literal">org.springframework.bundle.spring.core</code>)</p></li><li><p>spring-context.jar (bundle symbolic name
          <code class="literal">org.springframework.bundle.spring.context</code>)</p></li><li><p>spring-beans.jar (bundle symbolic name
          <code class="literal">org.springframework.bundle.spring.beans</code>)</p></li><li><p>spring-aop.jar (bundle symbolic name
          <code class="literal">org.springframework.bundle.spring.aop</code>)</p></li></ul></div><p>In additional the following supporting library bundles are
      required. OSGi-ready versions of these libraries are shipped with the
      Spring Dynamic Modules distribution.</p><div class="itemizedlist"><ul type="disc"><li><p>aopalliance</p></li><li><p>backport-util (when running on JDK 1.4)</p></li><li><p>cglib-nodep (when proxying classes rather then
          interfaces, needed in most cases)</p></li><li><p>commons-logging API (SLF4J version highly recommended)</p></li><li><p>logging implementation such as log4j</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="app-deploy:spring-namespaces"></a>4.3.&nbsp;Spring XML authoring support</h2></div></div></div><p>Spring 2.0 introduced (among other things) <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springframework.org/spring/docs/2.5.x/reference/xsd-config.html" target="_top">
    	easier</a> XML configuration and <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springframework.org/spring/docs/2.5.x/reference/extensible-xml.html" target="_top">
    	extensible</a> XML authoring. The latter gives the ability of creating custom schemas that are discovered automatically (in non-OSGi environment)
    	by the Spring XML infrastructure by including them in the classpath. Spring-DM is aware of this process and supports it in OSGi environments so
    	that custom schemas are available to bundles that use them without any extra code or manifest declaration.</p><p>All bundles deployed in the OSGi space (whether they are <code class="literal">Spring-powered</code> or not) are scanned by Spring-DM for 
    	custom Spring namespace declaration (by checking the bundle space for<code class="literal">META-INF/spring.handlers</code> and 
    	<code class="literal">META-INF/spring.schemas</code>). If these are found, Spring-DM will make the schemas and the namespaces available through an OSGi
    	service that will be automatically used by Spring-powered bundles. This mean that if you deploy a bundle that uses a custom schema, all you have to do
    	is deploy the library that provides the namespace parser and the schema.
    	Bundles that embedded inside their classpath libraries that provide custom schemas will use these over those available in the OSGi space. However,
    	the namespaces of the embedded libraries will not shared with other bundles, that is, they will not be seen by any other bundle.</p><p>
    	In short, with using Spring-DM, custom Spring namespaces are supported transparently without any additional work. Embedded namespace providers will
    	have priority but will not be shared, as opposed to providers deployed as bundles which will be seen (and used) by others.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="app-deploy:imports-exports"></a>4.4.&nbsp;Importing and Exporting packages</h2></div></div></div><p>Refer to the OSGi Service Platform for details of the
      <code class="literal">Import-Package</code> and <code class="literal">Export-Package</code>
      manifest headers. Your bundle will need an
      <code class="literal">Import-Package</code> entry for every external package that
      the bundle depends on. If your bundle provides types that other bundles
      need access to, you will need <code class="literal">Export-Package</code> entries
      for every package that should be available from outside of the
      bundle.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="app-deploy:ext-libs"></a>4.5.&nbsp;Considerations when using external libraries</h2></div></div></div><div class="sidebar"><p class="title"><b>What is the context class loader?</b></p><p>
      	The thread context class loader was introduced in J2SE without much fanfare.
      	Below is a short definition for it, quoted from <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://java.sun.com/products/jndi/tutorial/beyond/misc/classloader.html" target="_top">one
      	</a> of the tutorials available on <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://java.sun.com/" target="_top">Java</a> site:
      	</p><p>
      	The Java 2 platform also introduced the notion of <span class="emphasis"><em>context class loader</em></span>. A thread's context class loader is, by default, 
      	set to the context class loader of the thread's parent. The hierarchy of threads is rooted at the primordial thread (the one that runs the program). 
      	The context class loader of the primordial thread is set to the class loader that loaded the application. So unless you explicitly change 
      	the thread's context class loader, its context class loader will be the application's class loader. That is, the context class loader can 
      	load the classes that the application can load. This loader is used by the Java runtime such as the RMI (Java Remote Method Invocation) to 
      	load classes and resources on behalf of the user application. The context class loader, like any Java 2 platform class loader, has a parent 
      	class loader and supports the same delegation model for class loading described previously.
      	</p></div><p>Many enterprise application libraries assume that all of the types
      and resources that comprise the application are accessible through the
      context class loader. While most developers do not use the context class 
      loader, the loader is used heavily by application servers, containers or 
      applications that are multi-threaded.</p><p>		      
      In OSGi R4, the set of types and resources
      available through the context class loader is undefined. 
      This means that the OSGi platform does not make a guarantee of the thread context 
      class loader value or in other words, it does not manage it.
      </p><p>
      Thus code (for example libraries) that performs manual class loading or that generates 
      new classes dynamically can cause problems when executed inside an OSGi environment.
      </p><p>Spring Dynamic Modules guarantees that during the creation of an
      application context on behalf of a given bundle, all of the types and
      resources on the bundle's classpath are accessible via the context class
      loader. Spring Dynamic Modules also allows you to control what is
      accessible through the context class loader when invoking external
      services and when servicing requests on exported services. See section 5
      for details on this.</p><p>Work is underway in the OSGi R5 timeframe to provide standardized
      support for dealing with generated classes and implicit class path
      dependencies introduced by third-party libraries. In the interim you may
      need to rely on workarounds such as the
      <code class="literal">DynamicImport-Package</code> manifest header, or the
      facilities provided by specific OSGi implementations such as Equinox's
      buddy mechanism. The Spring Dynamic Modules documentation contains more
      details on known issues with common enterprise libraries and the
      workarounds.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="app-deploy:troubleshooting"></a>4.6.&nbsp;Diagnosing problems</h2></div></div></div><p>Your chosen OSGi platform implementation should be able to provide
      you with a good deal of information about the current status of the OSGi
      environment. For example, starting Equinox with the
      <code class="literal">-console</code> argument provides a command-line console
      through which you can determine which bundles are installed and their
      states, the packages and services exported by bundles, find out why a
      bundle has failed to resolve, and drive bundles through the
      lifecycle.</p><p>In addition, Spring itself and the Spring Dynamic Modules bundles
      contain extensive logging instrumentation that can help you diagnose
      problems. The recommended approach is to deploy the Simple Logging
      Facade for Java (<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.slf4j.org/" target="_top">slf4j</a>)
      slf4j-api.jar and slf4j-log4j13.jar bundles (the jar files distributed
      by the project are valid OSGi bundles). Then you simply need to create a
      <code class="literal">log4j.properties</code> file in the root of your bundle
      classpath.</p><p>Note that Spring Dynamic Modules uses commons-logging API internally
      which means that its logging implementation is fully pluggable. Please see
      the FAQ and Resources pages for more information on other logging libraries
      besides log4j.
      </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="service-registry"></a>Chapter&nbsp;5.&nbsp;The Service Registry</h2></div></div></div><p>The OSGi service registry enables a bundle to publish objects to a
    shared registry, advertised via a given set of Java interfaces. Published
    services also have service properties associated with them in the
    registry.</p><p>Spring Dynamic Modules provides an <code class="literal">osgi</code> namespace for Spring (see
    <a href="#appendix-schema" title="Appendix&nbsp;F.&nbsp;Spring Dynamic Modules Schema">Appendix&nbsp;F, <i xmlns:xlink="http://www.w3.org/1999/xlink">Spring Dynamic Modules Schema</i></a>) that can be used to export 
    Spring beans as OSGi services, and
    to define references to services obtained via the service registry. The
    namespace elements may be used nested inside another top-level namespace
    (typically the Spring <code class="literal">beans</code> namespace), or within the top-level
    <code class="literal">osgi</code> element.</p><p>The following example shows the use of the <code class="literal">osgi</code>
    namespace within the familiar Spring beans element:</p><div class="programlistingco"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;;
&lt;beans xmlns="http://www.springframework.org/schema/beans"                               <span class="co">(1)</span>
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:osgi="http://www.springframework.org/schema/osgi"                               <span class="co">(2)</span>
   xsi:schemaLocation="http://www.springframework.org/schema/beans   
       http://www.springframework.org/schema/beans/spring-beans.xsd                      <span class="co">(3)</span>
       http://www.springframework.org/schema/osgi  
       http://www.springframework.org/schema/osgi/spring-osgi.xsd"&gt;

    &lt;osgi:service id="simpleServiceOsgi" ref="simpleService"                             <span class="co">(4)</span>
      interface="org.xyz.MyService" /&gt;
&lt;/beans&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>Use Spring Framework <code class="literal">beans</code> schema as the default namespace.
            </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>Import Spring Dynamic Modules schema and associate a prefix with its namespace (<code class="literal">osgi</code> in this example).
            </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>Make sure to import Spring beans schema version <span class="emphasis"><em>2.5</em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>Use Spring Dynamic Modules elements using the declared namespace prefix (in this example <code class="literal">osgi</code>).</p></td></tr></table></div></div><p>Using the OSGi namespace as a top-level namespace, the same service
    would be declared as follows:</p><div class="programlistingco"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans:beans                                                                             <span class="co">(1)</span>
   xmlns="http://www.springframework.org/schema/osgi"                                    <span class="co">(2)</span>
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:beans="http://www.springframework.org/schema/beans"                             <span class="co">(3)</span>
   xsi:schemaLocation="http://www.springframework.org/schema/osgi  
       http://www.springframework.org/schema/osgi/spring-osgi.xsd
       http://www.springframework.org/schema/beans   
       http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;                    <span class="co">(4)</span>

    &lt;service id="simpleServiceOsgi" ref="simpleService"                                  <span class="co">(5)</span>
       interface="org.xyz.MyService" /&gt;

&lt;/beans:beans&gt;                                                                           <span class="co">(1)</span>
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p><code class="literal">beans</code> root element has to be prefixed with Spring Framework beans schema prefix (<code class="literal">beans</code> in this example).
            </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>Use Spring Dynamic Modules schema as the default namespace.
            </p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>Import Spring Framework <code class="literal">beans</code> schema and associate a prefix with its namespace (<code class="literal">beans</code> in this example).
            </p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>Make sure to import Spring beans schema version <span class="emphasis"><em>2.5</em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p>Use Spring Dynamic Modules elements without any prefix.</p></td></tr></table></div></div><p>Using the OSGi namespace as a top-level namespace is particularly
    convenient when following the recommendation of <a href="#app-deploy:headers" title="4.1.&nbsp;Bundle format and Manifest headers">Section&nbsp;4.1, &#8220;Bundle format and Manifest headers&#8221;</a> to use a
    dedicated configuration file for all OSGi-related declarations.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="service-registry:export"></a>5.1.&nbsp;Exporting a Spring bean as an OSGi service</h2></div></div></div><p>The <code class="literal">service</code> element is used to define a bean
      representing an exported OSGi service. At a minimum you must specify the
      bean to be exported, and the <span class="emphasis"><em>service interface</em></span> that
      the service advertises.</p><p>For example, the declaration</p><pre class="programlisting">&lt;service ref="beanToPublish" interface="com.xyz.MessageService"/&gt;</pre><p>exports the bean with name <code class="literal">beanToPublish</code> with
      interface <code class="literal">com.xyz.MessageService</code>. The published
      service will have a service property with the name
      <code class="literal">org.springframework.osgi.bean.name</code> set to the name of
      the target bean being registered (<code class="literal">beanToPublish</code> in
      this case).</p><p>The bean <span class="emphasis"><em>defined</em></span> by the
      <code class="literal">service</code> element is of type
      <code class="interfacename">org.osgi.framework.ServiceRegistration</code> and is the
      <code class="interfacename">ServiceRegistration</code> object resulting from registering
      the exported bean with the OSGi service registry. By giving this bean an
      id you can inject a reference to the
      <code class="interfacename">ServiceRegistration</code> object into other beans if
      needed. For example:</p><pre class="programlisting">&lt;service id="myServiceRegistration" ref="beanToPublish"
    interface="com.xyz.MessageService"/&gt;</pre><p>As an alternative to exporting a named bean, the bean to be
      exported to the service registry may be defined as an anonymous inner
      bean of the service element. Typically the top-level namespace would be
      the <code class="literal">beans</code> namespace when using this style:</p><pre class="programlisting">&lt;osgi:service interface="com.xyz.MessageService"&gt;
  &lt;bean class="SomeClass"&gt;
     ...
  &lt;/bean&gt;
&lt;/osgi:service&gt;</pre><p>If the bean to be exported implements the
      <code class="interfacename">org.osgi.framework.ServiceFactory</code> interface then the
      <code class="interfacename">ServiceFactory</code> contract is honored as per section 5.6
      of the OSGi Service Platform Core Specification. As an alternative to
      implementing this OSGi API, Spring Dynamic Modules introduces a new bean
      scope, the <code class="literal">bundle</code> scope. When a bean with bundle
      scope is exported as an OSGi service then one instance of the bean will
      be created for each unique client (service importer) bundle that
      obtains a reference to it through the OSGi service registry. When a
      service importing bundle is stopped, the bean instance associated with
      it is disposed. To declare a bean with <code class="literal">bundle</code> scope
      simply use the <code class="literal">scope</code> attribute of the
      <code class="literal">bean</code> element:</p><pre class="programlisting">&lt;osgi:service ref="beanToBeExported" interface="com.xyz.MessageService"/&gt;

&lt;bean id="beanToBeExported" scope="bundle" class="com.xyz.MessageServiceImpl"/&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="service-registry:export:intfs"></a>5.1.1.&nbsp;Controlling the set of advertised service interfaces for
        an exported service</h3></div></div></div><p>The OSGi Service Platform Core Specification defines the term
        <span class="emphasis"><em>service interface</em></span> to represent the specification
        of a service's public methods. Typically this will be a Java
        interface, but the specification also supports registering service
        objects under a class name, so the phrase <span class="emphasis"><em>service
        interface</em></span> can be interpreted as referring to either an
        interface or a class.</p><p>There are several options for specifying the service
        interface(s) under which the exported service is registered. The
        simplest mechanism, shown above, is to use the
        <code class="literal">interface</code> attribute to specify a fully-qualified
        interface name. To register a service under multiple interfaces the
        nested <code class="literal">interfaces</code> element can be used in place of
        the <code class="literal">interface</code> attribute.</p><pre class="programlisting">&lt;osgi:service ref="beanToBeExported"&gt;
  &lt;osgi:interfaces&gt;
     &lt;value&gt;com.xyz.MessageService&lt;/value&gt;
     &lt;value&gt;com.xyz.MarkerInterface&lt;/value&gt;
  &lt;/osgi:interfaces&gt;
&lt;/osgi:service&gt;</pre><p>It is illegal to use both <code class="literal">interface</code> attribute and
		<code class="literal">interfaces</code> element at the same time - use only one of them.
		</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="service-registry:export:auto-export"></a>5.1.1.1.&nbsp;Detecting the advertised interfaces at runtime</h4></div></div></div><div class="sidebar"><p class="title"><b>Hierarchy visibility</b></p><p>Note that when using <code class="literal">auto-export</code>, only types visible to the
        	bundle exporting the service are registered. For example, a
        	super-interface <code class="literal">SI</code> would not be exported as a
        	supported service interface even when using
        	<code class="literal">auto-export="interfaces"</code> if <code class="literal">SI</code>
        	was not on the exporting bundle's classpath.</p><p>Even if exported service class does implement <code class="literal">SI</code> transitively based
        	on its parent, if the declaring bundle doesn't import the 
        	interface, the class is unknown to the exported service. While this 
        	might seem counter intuitive, it is actually one of the most powerful features of OSGi
        	which give the bundle authors control over the class visibility and path.
        	</p><p>Please see the FAQ for a more detailed explanation.</p></div><p>Using the <code class="literal">auto-export</code> attribute you can avoid
        the need to explicitly declare the service interfaces at all by analyzing the
        object class hierarchy and its interfaces.</p><p> 
        The <code class="literal">auto-export</code> attribute can have one of four
        values:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">disabled</code> : the default value; no auto-detected of service
            interfaces is undertaken and the <code class="literal">interface</code>
            attribute or <code class="literal">interfaces</code> element must be used
            instead.</p></li><li><p><code class="literal">interfaces</code> : the service will be registered using all of the
            Java interface types implemented by the bean to be exported</p></li><li><p><code class="literal">class-hierarchy</code> : the service will be registered using the
            exported bean's implementation type and super-types</p></li><li><p><code class="literal">all-classes</code> : the service will be registered using the exported
            bean's implementation type and super-types plus all interfaces
            implemented by the bean.</p></li></ul></div><p>
		<code class="literal">auto-export</code> and <code class="literal">interface(s)</code> option are not exclusive; both
		can be used at the same time for fine grained control over the advertised interfaces if there is such
		a need. However, the former	option should be enough for most cases. 
		</p><p>For example, to automatically register a bean under all of the
        interfaces that it supports you would declare:</p><pre class="programlisting">&lt;service ref="beanToBeExported" auto-export="interfaces"/&gt;</pre><p>Given the interface hierarchy:</p><pre class="programlisting">public interface SuperInterface {}

public interface SubInterface extends SuperInterface {}</pre><p>then a service registered as supporting the
        <code class="literal">SubInterface</code> interface is <span class="emphasis"><em>not</em></span>
        considered a match in OSGi when a lookup is done for services
        supporting the <code class="literal">SuperInterface</code> interface. For this
        reason it is a best practice to export all interfaces supported by the
        service being registered explicitly, using either the
        <code class="literal">interfaces</code> element or
        <code class="literal">auto-export="interfaces"</code>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="service-registry:export:props"></a>5.1.2.&nbsp;Controlling the set of advertised properties for an
        exported service</h3></div></div></div><p>As previously described, an exported service is always
        registered with the service property
        <code class="literal">org.springframework.osgi.bean.name</code> set to the name
        of the bean being exported. Additional service properties can be
        specified using the nested <code class="literal">service-properties</code>
        element. The <code class="literal">service-properties</code> element contains
        key-value pairs to be included in the advertised properties of the
        service. The key must be a string value, and the value must be a type
        recognized by OSGi Filters. See section 5.5 of the OSGi Service
        Platform Core Specification for details of how property values are
        matched against filter expressions.</p><p>The <code class="literal">service-properties</code> element must contain
        at least one nested <code class="literal">entry</code> element from the Spring
        beans namespace. For example:</p><pre class="programlisting">&lt;service ref="beanToBeExported" interface="com.xyz.MyServiceInterface"&gt;
  &lt;service-properties&gt;
    &lt;beans:entry key="myOtherKey" value="aStringValue"/&gt;
    &lt;beans:entry key="aThirdKey" value-ref="beanToExposeAsProperty"/&gt;
  &lt;/service-properties&gt;
&lt;/service&gt;</pre><p>The Spring Dynamic Modules roadmap includes support for
        exporting properties registered in the OSGi Configuration
        Administration service as properties of the registered service. See
        <a href="#appendix-roadmap" title="Appendix&nbsp;E.&nbsp;Roadmap">Appendix&nbsp;E, <i xmlns:xlink="http://www.w3.org/1999/xlink">Roadmap</i></a> for more details.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="service-registry:export:depends-on"></a>5.1.3.&nbsp;The depends-on attribute</h3></div></div></div><p>Spring will manage explicit dependencies of a service element,
        ensuring for example that the bean to be exported as a service is
        fully constructed and configured before exporting it. If a service has
        implicit dependencies on other components (including other service
        elements) that must be fully initialized before the service can be
        exported, then the optional <code class="literal">depends-on</code> attribute
        can be used to express these dependencies.</p><pre class="programlisting">&lt;service ref="beanToBeExported" interface="com.xyz.MyServiceInterface"
     depends-on="myOtherComponent"/&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="service-registry:export:ccl"></a>5.1.4.&nbsp;The context-class-loader attribute</h3></div></div></div><p>The OSGi Service Platform Core Specification (most current
        version is 4.1 at time of writing) does not specify what types and
        resources are visible through the context class loader when an
        operation is invoked on a service obtained via the service registry.
        Since some services may use libraries that make certain assumptions
        about the context class loader, Spring Dynamic Modules enables you to
        explicitly control the context class loader during service execution.
        This is achieved using the option
        <code class="literal">context-class-loader</code> attribute of the service
        element.</p><p>The permissible values for the
        <code class="literal">context-class-loader</code> attribute are
        <code class="literal">unmanaged</code> (the default) and
        <code class="literal">service-provider</code>. When the
        <code class="literal">service-provider</code> value is specified, Spring Dynamic
        Modules ensures that the context class loader can see all of the
        resources on the class path of the bundle exporting the service.</p><p class="remark"><i><span class="remark">When setting <code class="literal">context-class-loader</code> to <code class="literal">service-provider</code>, the service object will be proxied to
        handle the class loader. If the service advertises any concrete class then CGLIB library is required .</span></i></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="service-registry:export:ranking"></a>5.1.5.&nbsp;The ranking attribute</h3></div></div></div><p>When registering a service with the service registry, you may
        optionally specify a service ranking (see section 5.2.5 of the OSGi
        Service Platform Core Specification). When a bundle looks up a service
        in the service registry, given two or more matching services the one
        with the highest ranking will be returned. The default ranking value
        is zero. To explicitly specify a ranking value for the registered
        service, use the optional <code class="literal">ranking</code> attribute.</p><pre class="programlisting">&lt;service ref="beanToBeExported" interface="com.xyz.MyServiceInterface"
  ranking="9"/&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="service-registry:export:service:attributes"></a>5.1.6.&nbsp;<code class="literal">service</code> element attribute</h3></div></div></div><p>
       As a summary, the following table lists the attributes names, possible values and
       a short description for each of them.
       </p><div class="table"><a name="service-export-options"></a><p class="title"><b>Table&nbsp;5.1.&nbsp;OSGi &lt;service&gt; attributes</b></p><div class="table-contents"><table summary="OSGi <service&gt; attributes" width="100%" border="1"><colgroup><col align="center"><col><col></colgroup><thead><tr><th align="center">Name</th><th>Values</th><th>Description</th></tr></thead><tbody><tr><td align="center">interface</td><td>fully qualified class name (such as <code class="literal">java.lang.Thread</code>)</td><td>the fully qualified name of the class under which the object will be exported</td></tr><tr><td align="center">ref</td><td>any bean name</td><td>Reference to the named bean to be exported as a service in the service registry.</td></tr><tr><td align="center">context-class-loader</td><td>unmanaged | service-provider</td><td>Defines how the context class loader will be managed when an operation is invoked on the 
                exported service. The default value is <code class="literal">unmanaged</code> which means that no management of 
                the context class loader is attempted. A value of <code class="literal">service-provider</code> guarantees that
                the context class loader will have visibility of all the resources on the class path of 
                bundle exporting the service.</td></tr><tr><td align="center">auto-export</td><td>disabled | interfaces | class-hierarchy | all-classes</td><td>Enables Spring to automatically manage the set of service interfaces advertised for the
				service. By default this facility is <code class="literal">disabled</code>. A value of <code class="literal">interfaces</code> advertises all 
                of the Java interfaces supported by the exported service. A value of <code class="literal">class-hierarchy</code> 
                advertises all the Java classes in the hierarchy of the exported service. A value of 
                <code class="literal">all-classes</code> advertises all Java interfaces and classes.</td></tr><tr><td align="center">ranking</td><td>any integer value</td><td>Specify the service ranking to be used when advertising the service. Default value is 0.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="service-registry:export:lifecycle"></a>5.1.7.&nbsp;Service registration and unregistration lifecycle</h3></div></div></div><p>The service defined by a <code class="literal">service</code> element is
        registered with the OSGi service registry when the application context
        is first created. It will be unregistered automatically when the
        bundle is stopped and the application context is disposed.</p><p>If you need to take some action when a service is unregistered
        because its dependencies are not satisfied (or when it is registered),
        then you can define a listener bean using the nested
        <code class="literal">registration-listener</code> element.</p><p>The declaration of a registration listener must use either the
        <code class="literal">ref</code> attribute to refer to a top-level bean
        definition, or declare an anonymous listener bean inline. For
        example:</p><div class="programlistingco"><pre class="programlisting">&lt;service ref="beanToBeExported" interface="SomeInterface"&gt;
  &lt;registration-listener ref="myListener"                                                <span class="co">(1)</span>
    registration-method="serviceRegistered"                                              <span class="co">(2)</span>
    unregistration-method="serviceUnregistered"/&gt;                                        <span class="co">(2)</span>
  &lt;registration-listener
     registration-method="register"&gt;                                                     <span class="co">(3)</span>
     &lt;bean class="SomeListenerClass"/&gt;                                                   <span class="co">(4)</span>
  &lt;/registration-listener&gt;
&lt;/service&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>Listener declaration referring to a top-level bean declaration.
            </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>Indicate the <code class="literal">registration</code> and <code class="literal">unregistration</code> methods.</p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>Declare only a <code class="literal">registration</code> custom method for this listener.</p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>Nested listener bean declaration.</p></td></tr></table></div></div><p>The optional <code class="literal">registration-method</code> and
        <code class="literal">unregistration-method</code> attributes specify the names
        of the methods defined on the listener bean that are to be invoked
        during registration and unregistration. A registration and unregistration 
        callback methods must have a signature matching one of the following formats:</p><pre class="programlisting">public void anyMethodName(ServiceType serviceInstance, Map serviceProperties);</pre><pre class="programlisting">public void anyMethodName(ServiceType serviceInstance, Dictionary serviceProperties);</pre><p>where <code class="literal">ServiceType</code> can be any type compatible
        with the exported service interface of the service.</p><p>The register callback is invoked when the service is initially
        registered at startup, and whenever it is subsequently re-registered.
        The unregister callback is invoked during the service unregistration process, 
        no matter the cause (such as the owning bundle stopping).</p><p>Spring-DM will use the declared <code class="literal">ServiceType</code> argument type
        and invoke the registration/unregistration method only when a service of a compatible type
        will be registered/unregistered.</p><p><code class="literal">serviceProperties</code> represents a map holding all the properties
        of the registered/unregistered service. To preserve compatibility with the OSGi specification
        this argument can be cast, if needed, to a <code class="literal">java.util.Dictionary</code>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="service-registry:export:lifecycle:interface"></a>5.1.7.1.&nbsp;Using <code class="interfacename">OsgiServiceRegistrationListener</code> interface</h4></div></div></div><p>
        While we discourage, it is possible to implement a Spring-DM specific interface, namely 
        <code class="interfacename">org.springframework.osgi.service.exporter.OsgiServiceRegistrationListener</code> which avoids the need
        to declare the <code class="literal">registration-method</code> and <code class="literal">unregistration-method</code>.
        However, by implementing <code class="interfacename">OsgiServiceRegistrationListener</code>, your code
        becomes Spring-DM aware (which goes against the POJO philosophy).
        </p><p>It is possible for a listener to implement <code class="interfacename">OsgiServiceRegistrationListener</code> interface and
        declare custom methods. In this case, the Spring-DM interface methods will be called first, followed by the custom methods.
        </p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="service-registry:refs"></a>5.2.&nbsp;Defining references to OSGi services</h2></div></div></div><p>Spring Dynamic Modules supports the declaration of beans that
      represent services accessed via the OSGi Service Registry. In this
      manner references to OSGi services can be injected into application
      components. The service lookup is made using the service interface type
      that the service is required to support, plus an optional filter
      expression that matches against the service properties published in the
      registry.</p><p>For some scenarios, a single matching service that meets the
      application requirements is all that is needed. The
      <code class="literal">reference</code> element defines a reference to a single
      service that meets the required specification. In other scenarios,
      especially when using the OSGi <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.osgi.org/documents/osgi_technology/whiteboard.pdf" target="_top">whiteboard
      pattern</a>, references to <span class="emphasis"><em>all available</em></span>
      matching services are required. Spring Dynamic Modules supports the
      management of this set of references as a <code class="interfacename">List</code>,
      <code class="interfacename">Set</code> collection.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="service-registry:refs:singular"></a>5.2.1.&nbsp;Referencing an individual service</h3></div></div></div><p>The <code class="literal">reference</code> element is used to define a
        reference to a service in the service registry.</p><p>Since there can be multiple service matching a given description,
        the service returned is the service that would be returned by a call to
        <code class="literal">BundleContext.getServiceReference</code>. This means that
        the service with the highest ranking will be returned, or if there is
        a tie in ranking, the service with the lowest service id (the service
        registered first with the framework) is returned (please see Section 5
        from the OSGi spec for more information on the service selection algorithm).</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="service-registry:refs:singular:interface"></a>5.2.1.1.&nbsp;Controlling the set of advertised interfaces for the imported service</h4></div></div></div><p>The <code class="literal">interface</code> attribute identifies the service
	        interface that a matching service must implement. For example, the
	        following declaration creates a bean
	        <code class="literal">messageService</code>, which is backed by the service
	        returned from the service registry when querying it for a service
	        offering the <code class="interfacename">MessageService</code> interface.</p><pre class="programlisting">&lt;reference id="messageService" interface="com.xyz.MessageService"/&gt;</pre><p>Just like the <code class="literal">service</code> declaration, when specifying
	        multiple interfaces, use the nested <code class="literal">interfaces</code> element instead
	        of <code class="literal">interface</code> attribute:
	        </p><pre class="programlisting">&lt;osgi:reference id="importedOsgiService"&gt;
  &lt;osgi:interfaces&gt;
     &lt;value&gt;com.xyz.MessageService&lt;/value&gt;
     &lt;value&gt;com.xyz.MarkerInterface&lt;/value&gt;
  &lt;/osgi:interfaces&gt;
&lt;/osgi:reference&gt;</pre><p>It is illegal to use both <code class="literal">interface</code> attribute and
			<code class="literal">interfaces</code> element at the same time - use only one of them.
			</p><p>The bean defined by reference element implements all of the
	        advertised interfaces of the service that are visible to the bundle (called
	        <span class="emphasis"><em>greedy proxying</em></span>).
	        If the registered service interfaces include Java class types (as
	        opposed to interface types) then support for these types is subject to
	        the restrictions of Spring's AOP implementation (see the Spring
	        Reference Guide). In short, if the specified interfaces are classes
	        (rather then interfaces), then <code class="literal">cglib</code> library must be
	        available, and <code class="literal">final</code> methods are not
	        supported.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="service-registry:refs:singular:filter"></a>5.2.1.2.&nbsp;The <code class="literal">filter</code> attribute</h4></div></div></div><p>The optional <code class="literal">filter</code> attribute can be used
          to specify an OSGi filter expression and constrains the service
          registry lookup to only those services that match the given
          filter.</p><p>For example:</p><pre class="programlisting">&lt;reference id="asyncMessageService" interface="com.xyz.MessageService"
  filter="(asynchronous-delivery=true)"/&gt;</pre><p>will match only OSGi services that advertise <code class="interfacename">MessageService</code>
  		  interface and have the property named <code class="literal">asynchronous-delivery</code> set to value <code class="literal">true</code>.
  		  </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="service-registry:refs:singular:bean-name"></a>5.2.1.3.&nbsp;The <code class="literal">bean-name</code> attribute</h4></div></div></div><p>The <code class="literal">bean-name</code> attribute is a convenient
          short-cut for specifying a filter expression that matches on the
          <code class="literal">bean-name</code> property automatically set when exporting a bean using the
          <code class="literal">service</code> element (see <a href="#service-registry:export" title="5.1.&nbsp;Exporting a Spring bean as an OSGi service">Section&nbsp;5.1, &#8220;Exporting a Spring bean as an OSGi service&#8221;</a>).</p><p>For example:</p><pre class="programlisting">&lt;reference id="messageService" interface="com.xyz.MessageService"
   bean-name="defaultMessageService"/&gt;</pre><p>will match only OSGi services that advertise <code class="interfacename">MessageService</code>
   		  interface and have the property named <code class="literal">org.springframework.osgi.bean.name</code> set
   		  to value <code class="literal">defaultMessageService</code>. In short, this means finding all Spring-DM exported
   		  beans that implement interface <code class="interfacename">MessageService</code> and are named
   		  <code class="literal">defaultMessageService</code>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="service-registry:refs:singular:cardinality"></a>5.2.1.4.&nbsp;The <code class="literal">cardinality</code> attribute</h4></div></div></div><div class="sidebar"><p class="title"><b>Nested &lt;reference&gt; declarations</b></p><p>In order for Spring-DM to detect mandatory dependencies, any
		    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-inner-beans" target="_top">nested/inner</a>
		    reference declaration will be transformed into top-level
		    one with a generated name.</p></div><p>The <code class="literal">cardinality</code> attribute is used to
          specify whether or not a matching service is required at all times.
          A cardinality value of <code class="literal">1..1</code> (the default)
          indicates that a matching service must always be available. A
          cardinality value of <code class="literal">0..1</code> indicates that a
          matching service is not required at all times (see section 4.2.1.6
          for more details). A <code class="literal">reference</code> with cardinality
          <code class="literal">1..1</code> is also known as a
          <span class="emphasis"><em>mandatory</em></span> service reference and, by default,
          application context creation is deferred until the reference is
          satisfied.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>It is an error to declare a mandatory reference to a
          service that is also exported by the same bundle, this behavior can
          cause application context creation to fail through either deadlock
          or timeout.</div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="service-registry:refs:singular:depends-on"></a>5.2.1.5.&nbsp;The depends-on attribute</h4></div></div></div><p>The <code class="literal">depends-on</code> attribute is used to specify
          that the service reference should not be looked up in the service
          registry until the named dependent bean has been
          instantiated.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="service-registry:refs:singular:tccl"></a>5.2.1.6.&nbsp;The context-class-loader attribute</h4></div></div></div><p>The OSGi Service Platform Core Specification (latest
          version is 4.1 at time of writing) does not specify what types and
          resources are visible through the context class loader when an
          operation is invoked on a service obtained via the service registry.
          Since some services may use libraries that make certain assumptions
          about the context class loader, Spring Dynamic Modules enables you
          to explicitly control the context class loader during service
          invocation. This is achieved using the option
          <code class="literal">context-class-loader</code> attribute of the
          <code class="literal">reference</code> element.</p><div class="sidebar"><p class="title"><b>context class loader management on the importer and exporter</b></p><p>
		      Spring-DM has the ability to do context class loader management on both
		      the importer and exporter side. Normally, if Spring-DM works on both sides,
		      only one side should have this feature enabled. However, if both sides 
		      (importer and exporter) take advantage of this capability, the last
		      entity in the call chain will win. This means that the exporter setting,
		      if enabled, will always override the importer setting (whatever that is). 
		    </p></div><p>The permissible values for the
          <code class="literal">context-class-loader</code> attribute are:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">client</code> - during the service invocation,
          	the context	class loader is guaranteed to be
          	able to see types on the classpath of the invoking bundle.
          	This is the default option.</p></li><li><p><code class="literal">service-provider</code> - during the service invocation,
          	the context	class loader is guaranteed to be
          	able to see types on the classpath of the bundle exporting
          	the service.</p></li><li><p><code class="literal">unmanaged</code> - no context class loader
          	management will occur during the service invocation</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="service-registry:refs:singular:reference:attributes"></a>5.2.1.7.&nbsp;<code class="literal">reference</code> element attributes</h4></div></div></div><p>
       	As a summary, the following table lists the <code class="literal">reference</code> element 
       	attributes names, possible values and a short description for each of them.
        </p><div class="table"><a name="reference-import-options"></a><p class="title"><b>Table&nbsp;5.2.&nbsp;OSGi &lt;reference&gt; attributes</b></p><div class="table-contents"><table summary="OSGi <reference&gt; attributes" width="100%" border="1"><colgroup><col align="center"><col><col></colgroup><thead><tr><th align="center">Name</th><th>Values</th><th>Description</th></tr></thead><tbody><tr><td align="center">interface</td><td>fully qualified class name (such as <code class="classname">java.lang.Thread</code>)</td><td>The fully qualified name of the class under which the object will be exported.</td></tr><tr><td align="center">filter</td><td>OSGi filter expression (such as <code class="literal">((asynchronous-delivery=true)</code>)</td><td>OSGi filter expression that is used to constrain the set of matching services
                in the service registry.</td></tr><tr><td align="center">bean-name</td><td>any string value</td><td>Convenient shortcut for specifying a filter expression that matches on the bean-name property 
                that is automatically advertised for beans published using the &lt;service&gt; element.</td></tr><tr><td align="center">context-class-loader</td><td>client |  service-provider | unmanaged</td><td>Defines how the context class loader is managed when invoking operations on a service
                backing this service reference. The default value is <code class="literal">client</code> which means that the context
                class loader has visibility of the resources on this bundle's classpath. Alternate
                options are <code class="literal">service-provider</code> which means that the context class loader has visibility of 
                resources on the bundle classpath of the bundle that exported the service, and <code class="literal">unmanaged</code>
               	which does not do any management of the context class loader.</td></tr><tr><td align="center">cardinality</td><td>0..1 | 1..1</td><td>Defines the required cardinality of the relationship to the backing service. If not specified, 
                the <code class="literal">default-cardinality</code> attribute will apply. A value is '1..1' means that a backing service 
                must exist (this is a mandatory service reference). A value of '0..1' indicates that it is 
                acceptable to be no backing service (an optional service reference).</td></tr><tr><td align="center">timeout</td><td>any positive long</td><td>The amount of time (in milliseconds) to wait for a backing service to be 
				available when an operation is invoked. If not specified, the <code class="literal">default-timeout</code> attribute will apply.
                </td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="service-registry:refs:singular:dynamics"></a>5.2.1.8.&nbsp;<code class="literal">reference</code> and OSGi Service Dynamics</h4></div></div></div><p>
	      The bean defined by the <code class="literal">reference</code> element
	      is unchanged throughout the lifetime of the application context
	      (the object reference remains constant). However, the OSGi service
	      that backs the reference may come and go at any time. For a
	      mandatory service reference (cardinality <code class="literal">1..1</code>),
	      creation of the application context will block until a matching
	      service is available. For an optional service reference 
	      (cardinality <code class="literal">0..1</code>), the
	      reference bean will be created immediately, regardless of whether or
	      not there is currently a matching service.</p><p>When the service backing a <code class="literal">reference</code> bean
	      goes away, Spring Dynamic Modules tries to replace the backing
	      service with another service matching the reference criteria. An
	      application may be notified of a change in backing service by
	      registering a <code class="literal">listener</code>. If no matching service is
	      available, then the <code class="literal">reference</code> is said to be
	      <span class="emphasis"><em>unsatisfied</em></span>. An unsatisfied mandatory service
	      causes any exported service (<code class="literal">service</code> bean) that
	      depends on it to be unregistered from the service registry until
	      such time as the reference is satisfied again. See
	      <a href="#service-registry:export-import-relationship" title="5.5.&nbsp;Relationship between the service exporter and service importer">Section&nbsp;5.5, &#8220;Relationship between the service exporter and service importer&#8221;</a> for more information.</p><p>When an operation is invoked on an unsatisfied
	      <code class="literal">reference</code> bean (either optional or mandatory),
	      the invocation blocks until the reference becomes satisfied. The
	      optional <code class="literal">timeout</code> attribute of the
	      <code class="literal">reference</code> element enables a timeout value (in
	      milliseconds) to be specified. If a timeout value is specified and
	      no matching service becomes available within the timeout period, an
	      unchecked <code class="classname">ServiceUnavailableException</code> is
	      thrown.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="service-registry:refs:singular:property-editor"></a>5.2.1.9.&nbsp;Getting a hold of the managed service reference</h4></div></div></div><p>Spring-DM can automatically convert a managed OSGi service to 
        service reference. That is, if the property into which a reference bean 
        is to be injected, has type <code class="interfacename">ServiceReference</code> (instead of the service
        interface supported by the reference), then the managed OSGi
        <code class="interfacename">ServiceReference</code> for the service will be injected
        in place of the service itself:</p><pre class="programlisting">
public class BeanWithServiceReference {
	private ServiceReference serviceReference;
	private SomeService service;
			
	// getters/setters ommitted
}</pre><div class="programlistingco"><pre class="programlisting">&lt;reference id="service" interface="com.xyz.SomeService"/&gt;
		
&lt;bean id="someBean" class="BeanWithServiceReference"&gt;
  &lt;property name="serviceReference" ref="service"/&gt;                                      <span class="co">(1)</span>
  &lt;property name="service" ref="service"/&gt;                                               <span class="co">(2)</span>
&lt;/bean&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>Automatic managed service to <code class="interfacename">ServiceReference</code> conversion.
            </p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>Managed service is injected without any conversion</p></td></tr></table></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
		The injected <code class="interfacename">ServiceReference</code> is managed by Spring-DM and will change
		at the same time as the referenced backing OSGi service instance.  
		</div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="service-registry:refs:collection"></a>5.2.2.&nbsp;Referencing a collection of services</h3></div></div></div><div class="sidebar"><p class="title"><b>Natural vs custom ordering</b></p><p>
		 Java collection API defines two interfaces for ordering objects -
		 <code class="interfacename">Comparable</code> and <span class="interface">Comparator</span>.
		 The first is meant to be implemented by objects for providing <span class="emphasis"><em>natural 
		 ordering</em></span>. <code class="classname">String</code>, <code class="classname">Long</code>
		 or <code class="classname">Date</code> are good examples of objects that implement the
		 <code class="interfacename">Comparable</code> interface.</p><p>
		 However, there are cases where sorting is different then the natural ordering or,
		 the objects meant to be sort do not implement <span class="interface">Comparable</span>. To
		 address this cases, <code class="interfacename">Comparator</code> interface was designed. 
		 </p><p>For more information on this subject, please consult the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://java.sun.com/docs/books/tutorial/collections/interfaces/order.html" target="_top">
		 Object ordering</a> chapter from Java 
		 <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://java.sun.com/docs/books/tutorial/collections/" target="_top">collection</a> tutorial,
		 </p></div><p>Sometimes an application needs access not simply to any service
        meeting some criteria, but to <span class="emphasis"><em>all</em></span> services
        meeting some criteria. Spring-DM allows the matching services may be held in a
        <code class="interfacename">List</code> or <code class="interfacename">Set</code> 
        (optionally sorted).</p><p>The difference between using a <code class="interfacename">List</code> and a
        <code class="interfacename">Set</code> to manage the collection is one of equality.
        Two or more services published in the registry (and with distinct
        service ids) may be "equal" to each other, depending on the
        implementation of equals used by the service implementations. Only one
        such service will be present in a set, whereas all services returned
        from the registry will be present in a list. For more details on collections,
        see <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://java.sun.com/docs/books/tutorial/collections/interfaces/index.html" target="_top">this</a> 
        tutorial.</p><p>The <code class="literal">set</code> and <code class="literal">list</code> schema elements
        are used to define collections of services with set or list semantics
        respectively.</p><p>These elements support the attributes
        <code class="literal">interface</code>, <code class="literal">filter</code>,
        <code class="literal">bean-name</code>, <code class="literal">cardinality</code>, and
        <code class="literal">context-class-loader</code>, with the same semantics as for
        the <code class="literal">reference</code> element. The allowable values for the
        <code class="literal">cardinality</code> attribute are <code class="literal">0..N</code>
        and <code class="literal">1..N</code>.</p><p>A cardinality value of
        <code class="literal">0..n</code> indicates that it is permissible for their to
        be no matching services. A cardinality value of
        <code class="literal">1..n</code> indicates that at least one matching service
        is required at all times. Such a reference is considered a
        <span class="emphasis"><em>mandatory</em></span> reference and any exported services
        from the same bundle (<code class="literal">service</code> defined beans) that
        depend on a mandatory reference will automatically be unregistered
        when the reference becomes unsatisfied, and reregistered when the
        reference becomes satisfied again.</p><p>The bean defined by a <code class="literal">list</code> element is of type
        <code class="interfacename">java.util.List</code>. The bean defined by a
        <code class="literal">set</code> element is of type
        <code class="interfacename">java.util.Set</code>.</p><p>The following example defines a bean of type <code class="interfacename">List</code> that 
        will contain all registered services supporting the
        <code class="literal">EventListener</code> interface:</p><pre class="programlisting">&lt;list id="myEventListeners" 
  interface="com.xyz.EventListener"/&gt;</pre><p>The members of the collection defined by the bean are managed
        dynamically by Spring. As matching services are registered and
        unregistered in the service registry, the collection membership will
        be kept up to date. Each member of the collection supports the service
        interfaces that the corresponding service was registered with and that
        are visible to the bundle.</p><p>Spring-DM supports sorted collections as well, both for set and list.</p><p>It is possible to specify a sorting order using either the
        <code class="literal">comparator-ref</code> attribute, or the nested
        <code class="literal">comparator</code> element. The
        <code class="literal">comparator-ref</code> attribute is used to refer to a
        named bean implementing <code class="interfacename">java.util.Comparator</code>. The
        <code class="literal">comparator</code> element can be used to define an inline
        bean. For example:</p><pre class="programlisting">&lt;set id="myServices" interface="com.xyz.MyService"
  comparator-ref="someComparator"/&gt;

&lt;list id="myOtherServices" 
  interface="com.xyz.OtherService"&gt;
  &lt;comparator&gt;
     &lt;beans:bean class="MyOtherServiceComparator"/&gt;
  &lt;/comparator&gt;
&lt;/list&gt;</pre><p>To sort using a natural ordering instead of an explicit
        comparator, you can use the <code class="literal">natural-ordering</code>
        element inside of <code class="literal">comparator</code>. You need to specify
        the basis for the natural ordering: based on the service references,
        following the <code class="interfacename">ServiceReference</code> natural ordering
        defined in the OSGi Core Specification section 6.1.2.3; or based on
        the services themselves (in which case the services must be
        <code class="interfacename">Comparable</code>).</p><pre class="programlisting">&lt;list id="myServices" interface"com.xyz.MyService"&gt;
  &lt;comparator&gt;&lt;natural-ordering basis="services"/&gt;&lt;/comparator&gt;
&lt;/list&gt;

&lt;set id="myOtherServices"interface="com.xyz.OtherService"&gt;
  &lt;comparator&gt;&lt;natural-ordering basis="service-references"/&gt;&lt;/comparator&gt;
&lt;/set&gt;</pre><p class="remark"><i><span class="remark">For a sorted set, a <code class="interfacename">SortedSet</code> implementation will be created.
		However, since JDK API do not provide a dedicated <code class="interfacename">SortedList</code>interface, 
		the sorted list will implement only the <code class="interfacename">List</code> interface.</span></i></p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="service-registry:refs:collection:attributes"></a>5.2.2.1.&nbsp;Collection (<code class="literal">list</code> and <code class="literal">set</code>) element attributes</h4></div></div></div><p>
		<code class="literal">list</code> and <code class="literal">set</code> elements support all the attributes available to
		<code class="literal">reference</code> element except the <code class="literal">timeout</code> attribute.
		
       	See the following table as a summary of the <code class="literal">list</code> and <code class="literal">set</code> element 
       	attribute names, possible values and a short description for each of them.
        </p><div class="table"><a name="collection-import-options"></a><p class="title"><b>Table&nbsp;5.3.&nbsp;&lt;list&gt;/&lt;set&gt; attributes</b></p><div class="table-contents"><table summary="<list&gt;/<set&gt; attributes" width="100%" border="1"><colgroup><col align="center"><col><col></colgroup><thead><tr><th align="center">Name</th><th>Values</th><th>Description</th></tr></thead><tbody><tr><td align="center">interface</td><td>fully qualified class name (such as <code class="classname">java.lang.Thread</code>)</td><td>The fully qualified name of the class under which the object will be exported.</td></tr><tr><td align="center">filter</td><td>OSGi filter expression (such as <code class="literal">((asynchronous-delivery=true)</code>)</td><td>OSGi filter expression that is used to constrain the set of matching services
                in the service registry.</td></tr><tr><td align="center">bean-name</td><td>any string value</td><td>Convenient shortcut for specifying a filter expression that matches on the bean-name property 
                that is automatically advertised for beans published using the &lt;service&gt; element.</td></tr><tr><td align="center">context-class-loader</td><td>client |  service-provider | unmanaged</td><td>Defines how the context class loader is managed when invoking operations on a service
                backing this service reference. The default value is <code class="literal">client</code> which means that the context
                class loader has visibility of the resources on this bundle's classpath. Alternate
                options are <code class="literal">service-provider</code> which means that the context class loader has visibility of 
                resources on the bundle classpath of the bundle that exported the service, and <code class="literal">unmanaged</code>
               	which does not do any management of the context class loader.</td></tr><tr><td align="center">cardinality</td><td>0..N | 1..N</td><td>Defines the required cardinality of the relationship to the backing service. If not specified, 
                the <code class="literal">default-cardinality</code> attribute will apply. A value is '1..N' means that a backing service 
                must exist (this is a mandatory service reference). A value of '0..N' indicates that it is 
                acceptable to be no backing service (an optional service reference).</td></tr><tr><td align="center">comparator-ref</td><td>any string value</td><td>Named reference to a bean acting as comparator for the declaring collection. Declaring a comparator automatically
                makes the declaring collection sorted.</td></tr></tbody></table></div></div><br class="table-break"><p>The table below lists the attributes available for the <code class="literal">comparator/natural</code> sub element.</p><div class="table"><a name="collection-import-comparator-options"></a><p class="title"><b>Table&nbsp;5.4.&nbsp;collection &lt;comparator&gt; attributes</b></p><div class="table-contents"><table summary="collection <comparator&gt; attributes" width="100%" border="1"><colgroup><col align="center"><col><col></colgroup><thead><tr><th align="center">Name</th><th>Values</th><th>Description</th></tr></thead><tbody><tr><td align="center">basis</td><td>service | service-reference</td><td>Indicate the element on which <span class="emphasis"><em>natural ordering</em></span> should apply - <code class="literal">service</code> for considering
                the service instance and <code class="literal">service-reference</code> for considering the service reference instead of the service.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="service-registry:refs:collection:dynamics"></a>5.2.2.2.&nbsp;<code class="literal">list</code> / <code class="literal">set</code> and OSGi Service Dynamics</h4></div></div></div><p>
          A collection of OSGi services will change its content during the lifetime
          of the application context since it needs to reflect the state of the OSGi
          space. As service are registered and unregistered, they will be added or
          removed from the collection.</p><p>While a <code class="literal">reference</code> declaration will try to
          find a replacement if the backing service is unregistered, the collection
          will simply remove the service from the collection. 
          Like <code class="literal">reference</code>, a collection with cardinality <code class="literal">1..N</code>
          is said to be mandatory while a collection with cardinality <code class="literal">0..N</code>
          is referred to as being optional.
          If no matching service is available then only mandatory collections become 
          <span class="emphasis"><em>unsatisfied</em></span>.
          That is if no service is available invoking an operation on:
          </p><div class="itemizedlist"><ul type="disc"><li>mandatory collection - will throw an unchecked <code class="classname">ServiceUnavailableException</code>.</li><li>optional collection - will <span class="emphasis"><em>not</em></span> throw any exceptions (however the collection will be empty).</li></ul></div><p>Just like <code class="literal">reference</code>, mandatory collections
          will trigger the unregistration of any exported service that depends
          upon it. See
	      <a href="#service-registry:export-import-relationship" title="5.5.&nbsp;Relationship between the service exporter and service importer">Section&nbsp;5.5, &#8220;Relationship between the service exporter and service importer&#8221;</a> for more information.
          </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="service-registry:refs:collection:iterator"></a>5.2.2.3.&nbsp;<code class="interfacename">Iterator</code> contract and service collections</h4></div></div></div><p>The recommend way of traversing a collection is by using an <code class="interfacename">Iterator</code>.
		  However, since OSGi services can come and go, the content of the managed service collection will be adjusted
		  accordingly. Spring-DM will transparently update all <code class="interfacename">Iterator</code>s held by 
		  the user so it is possible to safely traverse the collection while it is being modified. Moreover, the 
		  <code class="interfacename">Iterator</code>s will reflect all the changes made to the collection, even if 
		  they occurred after the <code class="interfacename">Iterator</code>s were created (that is during the iteration).
		  Consider a case where a collection shrinks significantly (for example a big number of OSGi
		  services are shutdown) right after an iteration started.
		  To avoid dealing with the resulting 'dead' service references,
		  Spring-DM iterators do not take collection snapshots (that can be inaccurate) 
		  but rather are updated on each service event so they reflect the latest collection state, 
		  no matter how fast or slow the iteration is.</p><p>It is important to note that a service update will only influence <code class="interfacename">Iterator</code>
		  operations that are executed after the event occurred. Services already returned by the iterator will not be
		  updated even if the backing service has been unregistered. As a side note, if an operation is invoked on
          such a service that has been unregistered, a <code class="literal">ServiceUnavailableException</code> will be thrown. 
		  </p><p>To conclude, while a <code class="literal">reference</code> declaration will search for candidates in case the
		  backing service has been unregistered, a service collections will not replace unregistered services returned
		  to the user. However, it will remove the unregistered services from the collection so future iterations will not
		  encounter them.
		  </p><p>Please note that the <code class="interfacename">Iterator</code> contract is guaranteed meaning that 
		  <code class="literal">next()</code> method <span class="emphasis"><em>always</em></span> obey the result of the previous 
		  <code class="literal">hasNext()</code> invocation.</p><div class="table"><a name="collection-iterator-contract"></a><p class="title"><b>Table&nbsp;5.5.&nbsp;Dynamic service collection <code class="interfacename">Iterator</code> contract</b></p><div class="table-contents"><table summary="Dynamic service collection Iterator contract" width="100%" border="1"><colgroup><col align="center"><col></colgroup><thead><tr><th align="center">hasNext() returned value</th><th>next() behaviour</th></tr></thead><tbody><tr><td align="center">true</td><td><span class="emphasis"><em>Always</em></span> return a non-null value, even when the collection has shrunk as services when away.
                </td></tr><tr><td align="center">false</td><td>per <code class="interfacename">Iterator</code> contract, <code class="classname">NoSuchElementException</code> is thrown.
                This applies even if other services are added to the collection</td></tr></tbody></table></div></div><br class="table-break"><p>
	      The behaviour described above, offers a consistent view over the collection even if its structure changes during iteration.
	      To simply <span class="emphasis"><em>refresh</em></span> the iterator, call <code class="literal">hasNext()</code> again. This will force the
	      <code class="literal">Iterator</code> to check again the collection status for its particular entry in the iteration.</p><p>
	 	  In addition, any elements added to the collection during iteration over a <span class="emphasis"><em>sorted</em></span>
          collection will only be visible if the iterator has not already passed
          their sort point.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="service-registry:refs:dynamics"></a>5.2.3.&nbsp;Dealing with the dynamics of OSGi imported services</h3></div></div></div><p>Whether you are using <code class="literal">reference</code>
      or <code class="literal">set</code> or <code class="literal">list</code>, Spring Dynamic
      Modules will manage the backing service. However there are cases
      where the application needs to be aware when the backing service
      is updated.</p><p>Such applications, that need to be aware of when the service
      backing a <code class="literal">reference</code> bean is bound and unbound, can
      register one or more listeners using the nested
      <code class="literal">listener</code> element.
      This element is available on both <code class="literal">reference</code> and
      <code class="literal">set</code>, <code class="literal">list</code> declarations.
      In many respects, the service importer listener declaration 
      is similar to the service exporter listener declaration 
      (<a href="#service-registry:export:lifecycle" title="5.1.7.&nbsp;Service registration and unregistration lifecycle">Section&nbsp;5.1.7, &#8220;Service registration and unregistration lifecycle&#8221;</a>).
      
      The <code class="literal">listener</code> element refers to a bean (either by name, 
      or by defining one inline)
      that will receive bind and unbind notifications. If this bean
      implements Spring-DM's
      <code class="interfacename">org.springframework.osgi.service.importer.OsgiServiceLifecycleListener</code>
      interface, then the <code class="literal">bind</code> and
      <code class="literal">unbind</code> operations in this interface will be
      invoked. Instead of implementing this interface (or in addition),
      custom bind and unbind callback methods may be named.</p><p>An example of declaring a listener that implements
      <code class="interfacename">OsgiServiceLifecycleListener</code>:</p><pre class="programlisting">&lt;reference id="someService" interface="com.xyz.MessageService"&gt;
  &lt;listener ref="aListenerBean"/&gt;
&lt;/reference&gt;</pre><p>An example of declaring an inline listener bean with custom
      bind and unbind methods:</p><pre class="programlisting">&lt;reference id="someService" interface="com.xyz.MessageService"&gt;
  &lt;listener bind-method="onBind" unbind-method="onUnbind"&gt;
     &lt;beans:bean class="MyCustomListener"/&gt;
  &lt;/listener&gt;
&lt;/reference&gt;</pre><p>If the listener bean implements the
      <code class="interfacename">OsgiServiceLifecycleListener</code> interface
      <span class="emphasis"><em>and</em></span> the listener definition specifies custom
      bind and unbind operations then both the
      <code class="literal">OsgiServiceLifecycleListener</code> operation and the
      custom operation will be invoked, in that order.</p><p>The signature of a custom bind or unbind method must be one
      of:</p><pre class="programlisting">public void anyMethodName(ServiceType service, Dictionary properties);

public void anyMethodName(ServiceType service, Map properties);

public void anyMethodName(ServiceReference ref);</pre><p>where <code class="literal">ServiceType</code> can be any type. Please note that
      bind and unbind callbacks are invoked <span class="emphasis"><em>only</em></span>
      if the backing service matches the type declared in the method signature(
      <code class="classname">ServiceType</code>). If you want the callbacks to be called 
      no matter the type, use <code class="classname">java.lang.Object</code> as a 
      <code class="literal">ServiceType</code>.</p><p>
      The <code class="literal">properties</code> parameter contains the set of properties 
      that the service was registered with.</p><p>If the method signature has a single argument of type
      <code class="interfacename">ServiceReference</code> then the
      <code class="interfacename">ServiceReference</code> of the service will be passed to
      the callback in place of the service object itself.</p><p>When the listener is used with a <code class="literal">reference</code> declaration:</p><div class="itemizedlist"><ul type="disc"><li>A <span class="emphasis"><em>bind</em></span> callback is invoked 
      when the reference is initially bound to a backing service, 
      and whenever the backing service is replaced by a new backing service.
      </li><li>An <span class="emphasis"><em>unbind</em></span> callback is only 
      invoked when the current backing service is unregistered, and no 
      replacement service is immediately available 
      (i.e., the <code class="literal">reference</code> becomes unsatisfied).</li></ul></div><p>When the listener is used with a collection declaration (<code class="literal">set</code> or 
	  <code class="literal">list</code>):</p><div class="itemizedlist"><ul type="disc"><li>A <span class="emphasis"><em>bind</em></span> callback is invoked 
      		when a new service is added to the collection.
      		</li><li>An <span class="emphasis"><em>unbind</em></span> callback is 
      		invoked when a service is unregistered and is removed
      		from the collection.</li></ul></div><p>Again note that service collections there is <span class="emphasis"><em>no</em></span> 
      notion of <span class="emphasis"><em>service rebind</em></span>:
      services are added or removed from the collection.</p><p>Bind and unbind callbacks are made synchronously as part of
      processing an OSGi <code class="literal">serviceChanged</code> event for the
      backing OSGi service, and are invoked on the OSGi thread that
      delivers the corresponding OSGi
      <code class="classname">ServiceEvent</code>.</p><p>The table below lists the attributes available for the <code class="literal">reference</code> <code class="literal">listener</code> sub element.</p><div class="table"><a name="reference-import-listener-options"></a><p class="title"><b>Table&nbsp;5.6.&nbsp;OSGi &lt;listener&gt; attributes</b></p><div class="table-contents"><table summary="OSGi <listener&gt; attributes" width="100%" border="1"><colgroup><col align="center"><col><col></colgroup><thead><tr><th align="center">Name</th><th>Values</th><th>Description</th></tr></thead><tbody><tr><td align="center">ref</td><td>bean name reference</td><td>Name based reference to another bean acting as listener.</td></tr><tr><td align="center">bind-method</td><td>string representing a valid method name</td><td>The name of the method to be invoked when a backing service is bound.</td></tr><tr><td align="center">unbind-method</td><td>string representing a valid method name</td><td>The name of the method to be invoked when a backing service is bound.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="service-registry:refs:listener-and-proxies"></a>5.2.4.&nbsp;Listener and service proxies</h3></div></div></div><p>While the importer listener provides access to the OSGi service bound at a certain point, it is important to note that the given argument is <span class="emphasis"><em>not</em></span> 
       the actual service but a <span class="emphasis"><em>proxy</em></span>. This can have subtle side effects especially with regards to service class name 
       and identity. The reason behind using a proxy is to prevent the listener from holding strong reference to the service (which can disappear
       at any point). Listeners interested in tracking certain services should not rely on instance equality (<code class="literal">==</code>). Object equality
       (<code class="methodname">equals</code>/<code class="methodname">hashcode</code>) can be used but only if the backing service has exposed the aforementioned methods
       as part of its contract (normally by declaring them on a certain published interface/class). If these methods are not published, the proxy will invoke its own method, not the targets. This is on purpose since, 
       while the proxy tries to be as transparent as possible, it is up to the developer to define the desired semantics. 
       </p><p>Thus, it is recommended (especially for <code class="literal">reference</code> importers) to do tracking based on just the service interface/contract 
       (not identity), service properties (see <code class="constant">org.osgi.framework.Constants#SERVICE_ID</code>) or service notification (bind/unbind).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="service-registry:refs:invoker-bundle-context"></a>5.2.5.&nbsp;Accessing the caller <code class="interfacename">BundleContext</code></h3></div></div></div><p>It is sometime useful for an imported service to know which bundle is using it
      at a certain time. To help with this scenarion, in Spring-DM imported services publish
      the importing bundle <code class="interfacename">BundleContext</code> through 
      <code class="classname">LocalBundleContext</code> class. Each time a method on the importer is invoked,
      the caller <code class="interfacename">BundleContext</code> will be made available, using
      a <code class="classname">ThreadLocal</code>, through <code class="methodname">getInvokerBundleContext()</code>.
      </p><p>Please be careful when using this class since it ties your code to Spring-DM API.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="service-registry:refs:listener-best-practices"></a>5.3.&nbsp;Exporter/Importer listener best practices</h2></div></div></div><p>As mentioned above, Spring-DM exporter and importer allow listeners to be
      used for receiving notifications on when services are bound, unbound, registered or 
      unregistered. Below you can find some guidance advices when working with listeners:
      </p><div class="itemizedlist"><ul type="disc"><li>
       	Do <span class="emphasis"><em>not</em></span> execute long activity tasks inside the listener. If you really
       	have to, use a separate thread for executing the work. The listener are called synchronously
       	and so try to be as fast as possible. Doing work inside the listener prevents other the event
       	to be sent to other listeners and the OSGi service to resume activity. 
      	</li><li>Use listener custom declaration as much as possible - it doesn't tie your code
      	to Spring-DM API and it doesn't enforce certain signature names.</li><li>If find yourself repeating bind/unbind method declarations for your listener definitions,
      	consider using Spring <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-child-bean-definitions" target="_top">
      	bean definition inheritance</a> to define a common definition that can be reused and customized
      	accordingly.
      	</li><li>Prefer <code class="interfacename">java.util.Map</code> instead of <code class="classname">java.util.Dictionary</code>
      	class. The first is an interface while the latter is a deprecated, abstract class. To preserve compatibility, Spring-DM
      	will pass to the listeners a <code class="interfacename">Map</code> implementation that can be casted, if needed, to a 
      	<code class="classname">Dictionary</code>.</li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="service-registry:refs:listener-best-practices:cycles"></a>5.3.1.&nbsp;Listener and cyclic dependencies</h3></div></div></div><p>There are cases where an exporter/importer listener needs a reference back to the bean it is defined on:</p><div class="programlistingco"><pre class="programlisting">&lt;bean id="listener" class="cycle.Listener"&gt;                                              <span class="co">(1)</span>
    &lt;property name="target" ref="importer" /&gt;                                            <span class="co">(2)</span>
&lt;/bean&gt;
	
&lt;osgi:reference id="importer" interface="SomeService"&gt;                                   <span class="co">(3)</span>
    &lt;osgi:listener bind-method="bind" ref="listener" /&gt;                                  <span class="co">(4)</span>
&lt;/osgi:reference&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>Listener bean</p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>Dependency listener -&gt; importer</p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>Importer declaration</p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>Dependency importer -&gt; listener</p></td></tr></table></div></div><p>
         The declaration above while valid, creates a dependecy between the <code class="literal">listener</code> and the importer it is defined upon. 
         In order to create the importer, the <code class="literal">listener</code> has to be resolved and created but in order to do that, 
         the importer called <code class="literal">service</code> needs to be retrieved (instantiated and configured). This cycle needs to be broken
         down so that at least one bean can be fully created and configured. This scenario is supported is supported by Spring-DM
         for both exporter and importers however, if the listener is defined as a nested bean, the cycle cannot be resolved:</p><div class="programlistingco"><pre class="programlisting">&lt;osgi:reference id="importer" interface="SomeService"&gt;                                   <span class="co">(1)</span>
    &lt;osgi:listener bind-method="bind"&gt;                                                   <span class="co">(2)</span>
        &lt;bean class="cycle.Listener"&gt;                                                    <span class="co">(3)</span>
            &lt;property name="target" ref="importer" /&gt;                                    <span class="co">(4)</span>
        &lt;/bean&gt;
    &lt;/osgi:listener&gt;
&lt;/osgi:reference&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>OSGi service importer</p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>Dependency between importer -&gt; listener</p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>Nested listener declaration</p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>Dependency nested listener -&gt; importer</p></td></tr></table></div></div><div class="sidebar"><p class="title"><b>Beans and Cycles</b></p><p>
         Cyclic dependencies (A depends on B which depends back on A) increase the complexity of your configuration
         and in most cases indicate a design issue. What beans should be created and destroyed first for example? 
         While they are a bad practice, the Spring container makes a best attempt to solve the cyclic configurations 
         when singletons are involved (since the instances can be cached). However this does not work all the time and
         depends heavily on your specific configuration (Can the bean class be partially initialized ? Does it rely on
         special <code class="interfacename">Aware</code> interfaces?  Are <code class="interfacename">BeanPostProcessor</code>s involved?)
         </p></div><p>The example above will fail since <code class="literal">service</code> bean cannot be initialized as it depends on the 
		listener. The same cycle was seen before but in this case there is subtle yet big different from
		the container perspective - the listener is declared as a nested/inner-bean (hence the missing bean <code class="literal">id</code>).
		Inner beans have the same life cycle as their declaring parents and do not have any name. By definition, they are not tracked
		by the container and are simply created on demand. Since the importer cannot be partially created and the nested listener cannot
		be cached, the container cannot break the cycle and create the beans. While the two configurations shown above seem similar, one works
		while the other does not. Another reason to not use cycles unless you really, really have to.</p><p>To conclude, if you need inside the listener to hold a reference to the exporter/importer on which the listener is declared,
		either declare the listener as a <span class="emphasis"><em>top-level</em></span> bean (as shown before) or consider doing <span class="emphasis"><em>dependency lookup</em></span>.
		However, the latter approach requires extra contextual information such as the <code class="interfacename">BeanFactory</code> to use and the bean
		name and is more fragile then <span class="emphasis"><em>dependency injection</em></span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>For those interested in the technical details, neither the exporter and importer cannot be partially initialized since 
			they require the application context <code class="classname">ClassLoader</code> which is requested through the 
			<code class="interfacename">BeanClassLoaderAware</code> which relies on a buit-in <code class="interfacename">BeanPostProcessor</code>
			which is applied only after the bean has been configured and is ready for initialization. If the <code class="classname">ClassLoader</code>
			was not required then the exporter/importer could have been partially initialized and the case above supported.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="service-registry:refs:global-defaults"></a>5.4.&nbsp;Service importer global defaults</h2></div></div></div><p>The <code class="literal">osgi</code> namespace allows offers two
  	  global attributes for specifying default behaviours for all
  	  importers declared in that file.</p><p>Thus, when using the <code class="literal">osgi</code> namespace to enclose
      <code class="literal">set</code>, <code class="literal">list</code> or 
      <code class="literal">reference</code> elements, one can use:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">default-timeout</code> - 
      can be used to specify the default timeout (in milliseconds) for all
      importer elements that do not explicitly specify one. For
      example:</p><div class="programlistingco"><pre class="programlisting">&lt;beans xmlns="http://www.springframework.org/schema/beans"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:osgi="http://www.springframework.org/schema/osgi"                            <span class="co">(1)</span>
          osgi:default-timeout="5000"&gt;                                                   <span class="co">(2)</span>

  &lt;reference id="someService" interface="com.xyz.AService" .../&gt;                         <span class="co">(3)</span>

  &lt;reference id="someOtherService" interface="com.xyz.BService"
       timeout="1000" .../&gt;                                                              <span class="co">(4)</span>

&lt;/beans:beans&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>Declare <code class="literal">osgi</code> namespace prefix.</p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>Declare <code class="literal">default-timeout</code>(in miliseconds) on the root element. 
			If the default is not set, it will have a value of 5 minutes. In this example, the 
			default value is 5 seconds.</p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>This <code class="literal">reference</code> will inherit the default timeout value since 
			it does not specify one. 
			This service reference will have a timeout of 5 seconds.</p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>This <code class="literal">reference</code> declares a timeout, overriding the default value.
			 This service reference will have a timeout of 1 second.</p></td></tr></table></div></div></li><li><p><code class="literal">default-cardinality</code> -
		can be used to specify the default cardinality for all
      	importer elements that do not explicitly specify one.
      	Possible values are <code class="literal">0..X</code> and <code class="literal">1..X</code>
      	where <code class="literal">X</code> is substituted at runtime to <code class="literal">1</code>
      	for <code class="literal">reference</code> elements or <code class="literal">N</code>
      	for collection types such as <code class="literal">set</code> or <code class="literal">list</code>.
      	</p><p>Consider the following example:</p><div class="programlistingco"><pre class="programlisting">&lt;beans:beans
      xmlns="http://www.springframework.org/schema/osgi"                                 <span class="co">(1)</span>
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:beans="http://www.springframework.org/schema/beans"                          <span class="co">(2)</span>
      xmlns:osgi="http://www.springframework.org/schema/osgi"                            <span class="co">(3)</span>
         osgi:default-cardinality="0..X"                                                 <span class="co">(4)</span>
         default-lazy-init="false"&gt;                                                      <span class="co">(5)</span>

  &lt;reference id="someService" interface="com.xyz.AService"/&gt;                             <span class="co">(6)</span>

  &lt;set id="someSetOfService" interface="com.xyz.BService"/&gt;                              <span class="co">(7)</span>

  &lt;list id="anotherListOfServices" interface="com.xyz.CService" cardinality="1..N"/&gt;     <span class="co">(8)</span>

&lt;/beans:beans&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left">(1)</td><td valign="top" align="left"><p>Declare Spring Dynamic Modules schema as the default namespace.</p></td></tr><tr><td width="5%" valign="top" align="left">(2)</td><td valign="top" align="left"><p>Import Spring Framework beans schema and associate a prefix with its namespace 
		    (<code class="literal">beans</code> in this example).</p></td></tr><tr><td width="5%" valign="top" align="left">(3)</td><td valign="top" align="left"><p>Import Spring Dynamic Modules schema and associate a prefix with its namespace 
		    (<code class="literal">osgi</code> in this example). This is requires since the global attributes
		    have to be declared to an element (<code class="literal">beans</code>) belonging to another schema.
		    To avoid ambiguity, the Spring-DM schema is imported under a specified prefix as well.</p></td></tr><tr><td width="5%" valign="top" align="left">(4)</td><td valign="top" align="left"><p>Declare <code class="literal">default-cardinality</code> on the root element. 
			If the default is not set, it will have a value of <code class="literal">1..N</code>. In this example, the 
			default value is <code class="literal">0..N</code>. Note the <code class="literal">osgi</code> prefix added to
			the global attribute.</p></td></tr><tr><td width="5%" valign="top" align="left">(5)</td><td valign="top" align="left"><p><code class="literal">beans</code> element attributes (such as <code class="literal">default-lazy-init</code>) 
			do not need a prefix since they are declared as being local and unqualified 
			(see the beans schema for more information).</p></td></tr><tr><td width="5%" valign="top" align="left">(6)</td><td valign="top" align="left"><p>
			The <code class="literal">reference</code> declaration will inherit the default cardinality value since it does not specify one.
			As <code class="literal">reference</code> represents a single service, its cardinality will be <code class="literal">0..1</code>.
			</p></td></tr><tr><td width="5%" valign="top" align="left">(7)</td><td valign="top" align="left"><p>
			The <code class="literal">set</code> declaration will inherit the default cardinality value since it does not specify one.
			As <code class="literal">set</code> (or <code class="literal">list</code>) represents a collection of service, 
			its cardinality will be <code class="literal">0..N</code>.
			</p></td></tr><tr><td width="5%" valign="top" align="left">(8)</td><td valign="top" align="left"><p>The <code class="literal">list</code> declaration specifies its cardinality (<code class="literal">1..N</code>),
			 overriding the default value.</p></td></tr></table></div></div></li></ul></div><p>The <code class="literal">default-*</code> attributes allow for concise and shorter declarations as well
      as easy propagation of changes (such as increasing or decreasing the timeout).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="service-registry:export-import-relationship"></a>5.5.&nbsp;Relationship between the service exporter and service importer</h2></div></div></div><p>An exported service may depend, either directly or indirectly,
        on other services in order to perform its function. If one of these
        services is considered a <span class="emphasis"><em>mandatory</em></span> dependency
        (has cardinality <code class="literal">1..x</code>) and the 
        dependency can no longer be satisfied
        (because the backing service has gone away and there is no suitable
        replacement available) then the exported service that depends on it
        will be automatically unregistered from the service registry - meaning
        that it is no longer available to clients. If the mandatory dependency
        becomes satisfied once more (by registration of a suitable service),
        then the exported service will be re-registered in the service
        registry.</p><p>This automatic unregistering and re-registering of exported
        services based on the availability of mandatory dependencies only
        takes into account declarative dependencies. If exported service
        <code class="literal">S</code> depends on bean <code class="literal">A</code>, which in
        turn depends on mandatory imported service <code class="literal">M</code>, and
        these dependencies are explicit in the Spring configuration file as
        per the example below, then when <code class="literal">M</code> becomes
        unsatisfied <code class="literal">S</code> will be unregistered. When
        <code class="literal">M</code> becomes satisfied again, <code class="literal">S</code>
        will be re-registered.</p><pre class="programlisting">&lt;osgi:service id="S" ref="A" interface="SomeInterface"/&gt;

&lt;bean id="A" class="SomeImplementation"&gt;
   &lt;property name="helperService" ref="M"/&gt;
&lt;/bean&gt; 

&lt;!-- the reference element is used to refer to a service
     in the service registry --&gt;
&lt;osgi:reference id="M" interface="HelperService"
     cardinality="1..1"/&gt;</pre><p>If however the dependency from <code class="literal">A</code> on
        <code class="literal">M</code> is not established through configuration as shown
        above, but instead at runtime through for example passing a reference
        to <code class="literal">M</code> to <code class="literal">A</code> without any
        involvement from the Spring container, then Spring Dynamic Modules
        will <span class="emphasis"><em>not</em></span> track this dependency.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="bundles"></a>Chapter&nbsp;6.&nbsp;Working with Bundles</h2></div></div></div><p>Spring-DM offers a dedicated schema element for interacting with existing
    bundles or for installing new ones. While it is not intended to be used as a replacement
    for proper OSGi services, the <code class="literal">bundle</code> element offers a very
    easy way of executing actions on bundles based on the lifecycle of the application
    context. 
    </p><p>The <code class="literal">bundle</code> element defines a bean of type
    <code class="interfacename">org.osgi.framework.Bundle</code>. It provides a simple way to
    work directly with bundles, including driving their lifecycle. In the
    simplest case all you need to do is specify the
    <code class="literal">symbolic-name</code> of the bundle you are interested
    in:</p><pre class="programlisting">&lt;bundle id="aBundle" symbolic-name="org.xyz.abundle"/&gt;</pre><p>The bean <code class="literal">aBundle</code> can now be injected into any property of 
    type <code class="interfacename">Bundle</code>.</p><p>If the needed bundle is not installed, one can use <code class="literal">location</code> attribute
    to indicate install or/and the <code class="literal">action</code>/<code class="literal">destroy-action</code> attributes
    provide declarative control over the bundle's lifecycle. The <code class="literal">location</code> attribute is 
    used to specify a URL where the bundle jar file artifact can be found. The
    <code class="literal">action</code> attribute specifies the lifecycle operation to
    be invoked on the bundle object. The supported action values are
    <code class="literal">install</code>, <code class="literal">start</code>,
    <code class="literal">update</code>, <code class="literal">stop</code>, and
    <code class="literal">uninstall</code>. These actions have the same semantics as the
    operations of the corresponding names defined on the
    <code class="literal">Bundle</code> interface (see the OSGi Service Platform Core
    Specification), with the exception that pre-conditions are weakened to
    allow for example a <span class="emphasis"><em>start</em></span> action to be specified against a bundle that
    is not currently installed (it will be installed first).</p><p>The following table shows how actions are interpreted for the given
    Bundle states:</p><div class="table"><a name="bundle-factory-actions"></a><p class="title"><b>Table&nbsp;6.1.&nbsp;&lt;bundle&gt; <code class="literal">action</code> values</b></p><div class="table-contents"><table summary="<bundle&gt; action values" width="100%" border="1"><colgroup><col align="center"><col><col></colgroup><thead><tr><th align="center">Action</th><th>UNINSTALLED</th><th>INSTALLED/RESOLVED</th><th>ACTIVE</th></tr></thead><tbody><tr><td align="center">START</td><td>installs and starts the bundle</td><td>starts the bundle</td><td>no action taken, bundle already started</td></tr><tr><td align="center">UPDATE</td><td>installs the bundle and then updates it (`Bundle.update()`)</td><td>updates the bundle</td><td>updates the bundle</td></tr><tr><td align="center">STOP</td><td>no action taken</td><td>no action taken</td><td>bundle is stopped</td></tr><tr><td align="center">UNINSTALL</td><td>no action taken</td><td>bundle is uninstalled</td><td>bundle is stopped and then uninstalled</td></tr></tbody></table></div></div><br class="table-break"><p>For example:</p><pre class="programlisting">&lt;!-- ensure this bundle is installed and started --&gt;;
&lt;bundle id="aBundle" symbolic-name="org.xyz.abundle"
   location="http://www.xyz.com/bundles/org.xyz.abundle.jar"
   action="start"/&gt;</pre><p>The following table lists the <code class="literal">bundle</code> element attributes names, 
    possible values and a short description for each of them.
    </p><div class="table"><a name="bundle-options"></a><p class="title"><b>Table&nbsp;6.2.&nbsp;&lt;bundle&gt; attributes</b></p><div class="table-contents"><table summary="<bundle&gt; attributes" width="100%" border="1"><colgroup><col align="center"><col><col></colgroup><thead><tr><th align="center">Name</th><th>Values</th><th>Description</th></tr></thead><tbody><tr><td align="center">symbolic-name</td><td>any valid symbolic-name String</td><td>The bundle symbolic name of the bundle object. Normally used when interacting with an already 
             installed bundle.</td></tr><tr><td align="center">location</td><td>String that can be converted into an <code class="literal">URL</code></td><td>Location used to install, update or/and identify a bundle.</td></tr><tr><td align="center">action</td><td>start | stop | install | uninstall | update</td><td>Lifecyle action to drive on the bundle. The action is executed at startup.</td></tr><tr><td align="center">destroy-action</td><td>(same as action)</td><td>Lifecyle action to drive on the bundle. The action is executed at shutdown.</td></tr></tbody></table></div></div><br class="table-break"><p>The samples that ship with the Spring Dynamic Modules project
    include further support for a <code class="literal">virtual-bundle</code> element
    that can be used to create and install OSGi bundles on the fly from
    existing artifacts.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="testing"></a>Chapter&nbsp;7.&nbsp;Testing OSGi based Applications</h2></div></div></div><p>By following best practices and using the Spring Dynamic Modules
    support, your bean classes should be easy to unit test as they will have
    no hard dependencies on OSGi, and the few OSGi APIs that you may interact
    with (such as <code class="interfacename">BundleContext</code>) are interface-based 
    and easy to mock. Whether you want to do unit testing or <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://en.wikipedia.org/wiki/Integration_testing" target="_top">
    integration</a> testing, Spring-DM can ease your task.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="testing:mocks"></a>7.1.&nbsp;OSGi Mocks</h2></div></div></div><div class="sidebar"><p class="title"><b>Mocks vs Stubs</b></p><p>There are various strategies to unit test code
     that requires colaborators. The two most popular strategies
     are <span class="emphasis"><em>stubs</em></span> and <span class="emphasis"><em>mocks</em></span>.
     </p><p>
     See <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://martinfowler.com/articles/mocksArentStubs.html" target="_top">
     this</a> article by Martin Fowler which describes in detail the difference 
     between them.</p></div><p>
    Even though most OSGi API are interfaces and creating mocks using a specialized
    library like <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.easymock.org/" target="_top">EasyMock</a> is fairly
    simple, in practice the amount of code of setting the code (especially on JDK 1.4)
    becomes cumbersome. To keep the tests short and concise, Spring-DM provides OSGi
    mocks under <code class="literal">org.springframework.osgi.mock</code> package.</p><p>It's up to you to decide whether they are useful or not however, we make extensive
    use of them inside Spring-DM test suite. Below you can find a code snippet that you
    are likely to encounter in our code base:</p><pre class="programlisting">private ServiceReference reference;
private BundleContext bundleContext;
private Object service;
    
protected void setUp() throws Exception {
	reference = new MockServiceReference();
	bundleContext = new MockBundleContext() {

		public ServiceReference getServiceReference(String clazz) {
			return reference;
		}

		public ServiceReference[] getServiceReferences(String clazz, String filter) 
				throws InvalidSyntaxException {
			return new ServiceReference[] { reference };
		}
		
		public Object getService(ServiceReference ref) {
		    if (reference == ref)
		       return service;
		    super.getService(ref);
		}
	};

	...
}
	
public void testComponent() throws Exception {
    OsgiComponent comp = new OsgiComponent(bundleContext);
    
    assertSame(reference, comp.getReference());
    assertSame(object, comp.getTarget());
}</pre><p>As ending words, experiment with them and choose whatever style or library you feel most confortable with.
    In our test suite we use the aforementioned mocks, EasyMock library and plenty of integration testing (see below).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="testing:integration"></a>7.2.&nbsp;Integration Testing</h2></div></div></div><div class="sidebar"><p class="title"><b>What about JUnit4/TestNG?</b></p><p>While JUnit4/TestNG overcome the class inheritance
     problem that appears when building base JUnit classes, by decoupling
     the runner from the test through annotations, Spring-DM cannot use
     them since it has to support Java 1.4.</p><p>However, it is planned for the future to provide an optional,
     JVM 5-based testing extension to integrate the existing testing framework
     with the aforementioned libraries.
     </p></div><p>In a restricted environment such as OSGi, it's important to test the visibility and versioning of your classes, 
    the manifests or how your bundles interact with each other (just to name a few).</p><p> To ease integration testing, the Spring Dynamic Modules project provides a test class hierarchy
    (based on <code class="classname">org.springframework.osgi.test.AbstractOsgiTests</code>) that
    provides support for writing regular <code class="literal">JUnit</code> test cases that are then
    automatically executed in an OSGi environment.</p><p>In general, the scenario supported by Spring-DM testing framework is:</p><div class="itemizedlist"><ul type="disc"><li><p>start the OSGi framework (Equinox, Knopflerfish, Felix)</p></li><li><p>install and start any specified bundles required for the
        test</p></li><li><p>package the test case itself into a <code class="literal">on the fly</code> bundle,
        generate the manifest (if none is provided) and install it in the OSGi 
        framework</p></li><li><p>execute the test case inside the OSGi framework</p></li><li><p>shut down the framework</p></li><li><p>passes the test results back to the originating test case
        instance that is running outside of OSGi</p></li></ul></div><p>By following this sequence it is trivial to write JUnit-based
    integration tests for OSGi and have them integration into any environment
    (IDE, build (ant, maven), etc.) that can work with JUnit.</p><p>The rest of this chapter details (with examples) the features
    offered by Spring-DM testing suite.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="testing:integration:simple-test"></a>7.2.1.&nbsp;Creating a simple OSGi integration test</h3></div></div></div><p>
      While the testing framework contains several classes that offer specific
      features, it is most likely that your test cases will extend
      <code class="classname">org.springframework.osgi.test.AbstractConfigurableBundleCreatorTests</code> (at least
      this is what we use in practice).
      </p><p>Let's extend this class and interact with the OSGi platform through
      the <code class="literal">bundleContext</code> field:</p><pre class="programlisting">public class SimpleOsgiTest extends AbstractConfigurableBundleCreatorTests {

public void testOsgiPlatformStarts() throws Exception {
	System.out.println(bundleContext.getProperty(Constants.FRAMEWORK_VENDOR));
	System.out.println(bundleContext.getProperty(Constants.FRAMEWORK_VERSION));
	System.out.println(bundleContext.getProperty(Constants.FRAMEWORK_EXECUTIONENVIRONMENT));
}
}</pre><p>Simply execute the test as you normally do with any JUnit test. On Equinox 3.2.x,
    the output is similar to:</p><pre class="programlisting">Eclipse
1.3.0
OSGi/Minimum-1.0,OSGi/Minimum-1.1,JRE-1.1,J2SE-1.2,J2SE-1.3,J2SE-1.4}</pre><p class="remark"><i><span class="remark">It's likely that you will see other log statements made by the testing
    framework during your test execution by these can be disabled and have only an informative
    value as they don't affect your test execution.</span></i></p><p>Note that you did not have to create any bundle, write any MANIFEST or
    bother with imports or exports, let alone starting and shutting down the OSGi
    platform. The testing framework takes care of these automatically
    when the test is executed.</p><p>Let's do some quering and figure out what the environment in which the tests run is.
    A simple way to do that is to query the <code class="interfacename">BundleContext</code>
    for the installed bundles:</p><pre class="programlisting">public void testOsgiEnvironment() throws Exception {
	Bundle[] bundles = bundleContext.getBundles();
	for (int i = 0; i &lt; bundles.length; i++) {
		System.out.print(OsgiStringUtils.nullSafeName(bundles[i]));
		System.out.print(", ");
	}
	System.out.println();
}</pre><p>The output should be similar to:</p><pre class="programlisting">OSGi System Bundle, asm.osgi, log4j.osgi, spring-test, spring-osgi-test, spring-osgi-core, 
    spring-aop, spring-osgi-io, slf4j-api, 
spring-osgi-extender, etc... TestBundle-testOsgiPlatformStarts-com.your.package.SimpleOsgiTest, 
</pre><p>As you can see, the testing framework installs the mandatory requirements required for running the 
    test such as the Spring, Spring-DM, slf4j jars among others.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="testing:integration:provisioning"></a>7.2.2.&nbsp;Installing test prerequisites</h3></div></div></div><div class="sidebar"><p class="title"><b>OSGi-friendly libraries</b></p><p>To work on OSGi environments, jars need to declare in their
       <code class="literal">MANIFEST.MF</code>, Export or Import packages; that is
       declare what classes they need or offer to other bundles.
       Most libraries are OSGi unaware and do not provide the proper manifest
       entries which means they are unusable in an OSGi environment.</p><p>At the moment, there are several initiatives in the open source space
       to provide the proper manifest - please see the FAQ for more information.
       </p></div><p>Besides the Spring-DM jars and the test itself is highly likely that you depend on 
     several libraries or your own code for the integration test.</p><p>Consider the following test that relies on Apache Commons 
     <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://commons.apache.org/lang/" target="_top">Lang</a>:</p><pre class="programlisting">import org.apache.commons.lang.time.DateFormatUtils;
    ...
  	public void testCommonsLangDateFormat() throws Exception {
		System.out.println(DateFormatUtils.format(new Date(), "HH:mm:ssZZ"));
	}
}</pre><p>Running the test however yields an exception:</p><pre class="programlisting">java.lang.IllegalStateException: Unable to dynamically start generated unit test bundle
     ...
Caused by: org.osgi.framework.BundleException: The bundle could not be resolved. 
Reason: Missing Constraint: Import-Package: org.apache.commons.lang.time; version="0.0.0"
    ...
	... 15 more
	</pre><p>The test requires <code class="literal">org.apache.commons.lang.time</code> package but there is no bundle
     that exports it. Let's fix this by installing a commons-lang bundle.</p><p>One can specify the bundles that she wants
     to be installed using <code class="literal">getTestBundlesNames</code> or <code class="literal">getTestBundles
     </code> method. The first one returns an array of String that indicate the bundle
     name, package and versioning through as a String while the latter returns an array of
     <code class="literal">Resource</code>s that can be used directly for installing the bundles.
     That is, use <code class="literal">getTestBundlesNames</code> when you rely on somebody else to locate
     (the most common case) the bundles and <code class="literal">getTestBundles</code> when you want to 
     locate the bundles yourself.
     </p><p>By default, the test suite uses the local <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://maven.apache.org" target="_top">maven2</a> 
     repository to locate the artifacts. The locator expects the bundle String to be a comma separated
     values containing the artifact group, name, version and (optionally) type.
     
     It's likely that in the future, various other locators will be available. One can plug in their own 
     locator through the <code class="interfacename">org.springframework.osgi.test.provisioning.ArtifactLocator</code> interface.
     </p><p>Let's fix our integration test by installing the required bundle (and some extra osgi libraries):</p><pre class="programlisting">protected String[] getTestBundlesNames() {
	 return new String[] { "org.springframework.osgi, cglib-nodep.osgi, 2.1.3-SNAPSHOT",
	 	"org.springframework.osgi, jta.osgi, 1.1-SNAPSHOT",
	 	"org.springframework.osgi, commons-lang.osgi, 2.3-SNAPSHOT" };
	 };
}</pre><p>Rerunning the test should show that these bundles are now installed in the OSGi platform.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>The artifacts mentioned above have to exist in your local maven repository.</div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="testing:integration:advanced-topics"></a>7.2.3.&nbsp;Advanced testing framework topics</h3></div></div></div><p>The testing framework allows a lot of customization to be made. This chapter
      details some of the existing hooks that you might want to know about. However, these
      are advanced topics as they increase the complexity of your test infrastructure.
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="testing:integration:customize-manifest"></a>7.2.3.1.&nbsp;Customizing the test manifest</h4></div></div></div><p>There are cases where the auto-generated test manifest does not suite the needs of the test.
      For example the manifest requires some different headers or a certain package needs to be an optional import.</p><p>
      For simple cases, one can work directly with the generated manifest - in the example below, the bundle class path
      is being specified:
      </p><pre class="programlisting">protected Manifest getManifest() {
      // let the testing framework create/load the manifest
      Manifest mf = super.getManifest();
      // add Bundle-Classpath:
      mf.getMainAttributes().putValue(Constants.BUNDLE_CLASSPATH, ".,bundleclasspath/simple.jar");
      return mf;
}</pre><p>      
      Another alternative is to provide your own manifest by overriding <code class="literal">getManifestLocations()</code>:</p><pre class="programlisting">protected String getManifestLocation() {
      return "classpath:com/xyz/abc/test/MyTestTest.MF";
}</pre><p>However each manifest needs the following entry:</p>&#8220;<span class="quote">Bundle-Activator: org.springframework.osgi.test.JUnitTestActivator</span>&#8221;<p>since without it, the testing infrastructure cannot function properly. Also, one needs to 
	  import JUnit, Spring and Spring-DM specific packages used by the base test suite:</p><pre class="programlisting">Import-Package: junit.framework,
  org.osgi.framework,
  org.apache.commons.logging,
  org.springframework.util,
  org.springframework.osgi.service,
  org.springframework.osgi.util,
  org.springframework.osgi.test,
  org.springframework.context</pre><p>Failing to import a package used by the test class will cause the test to fail with a 
	  <code class="literal">NoDefClassFoundError</code> error.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="testing:integration:specify-test-jar-content"></a>7.2.3.2.&nbsp;Customizing test bundle content</h4></div></div></div><p>By default, for the on-the-fly bundle, the testing infrastructure uses all the classes, xml and properties files
      found under <code class="literal">./target/test-classes</code> folder. This matches the project layout for maven which is used 
      (at the moment by Spring-DM). These settings can be configured in two ways:</p><div class="orderedlist"><ol type="1"><li><p>programmatically by overriding <code class="classname">AbstractConfigurableBundleCreatorTests</code> <code class="literal">getXXX</code>
         methods.</p></li><li><p>declaratively by creating a properties file having a similar name with the test case. For example, test
        <code class="literal">com.xyz.MyTest</code> will have the properties file named <code class="literal">com/xyz/MyTest-bundle.properties</code>.
        If found, the following properties will be read from the file:</p><div class="table"><a name="integration-test-jar-setting-file"></a><p class="title"><b>Table&nbsp;7.1.&nbsp;Default test jar content settings</b></p><div class="table-contents"><table summary="Default test jar content settings" width="100%" border="1"><colgroup><col align="center"><col><col></colgroup><thead><tr><th align="center">Property Name</th><th>Default Value</th><th>Description</th></tr></thead><tbody><tr><td align="center">root.dir</td><td>file:./target/test-classes</td><td>the root folder considered as the jar root</td></tr><tr><td align="center">include.patterns</td><td>/**/*.class, /**/*.xml, /**/*.properties</td><td>Comma-separated string of Ant-style patterns</td></tr><tr><td align="center">manifest</td><td>(empty)</td><td>manifest location given as a String. By default it's empty meaning the manifest
	        will be created by the test framework rather then being supplied by the user.</td></tr></tbody></table></div></div><br class="table-break"><p>This option is handy when creating specific tests that need to include certain resources (such as localization files 
		or images).</p></li></ol></div><p>Please consult <code class="classname">AbstractConfigurableBundleCreatorTests</code> and 
		<code class="classname">AbstractOnTheFlyBundleCreatorTests</code> tests for more customization hooks.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="testing:integration:understanding-manifest-creator"></a>7.2.3.3.&nbsp;Understanding the <code class="code">MANIFEST.MF</code> generation</h4></div></div></div><p>A useful feature of the testing framework represents the automatic creation of the test manifest based on the test bundle content. The manifest 
      creator component uses byte-code analysis to determine the packages imported by the test classes so that it can generate the proper OSGi directives for them.
      Since the generated bundle is used for running a test, the creator will use the following assumptions:</p><div class="itemizedlist"><ul type="disc"><li><p>No packages will be exported.</p><p>The <span class="emphasis"><em>on-the-fly</em></span> bundle is used for running a test which 
      	(usually) consumes OSGi packages for its execution. This behaviour can be changed by <a href="#testing:integration:customize-manifest" title="7.2.3.1.&nbsp;Customizing the test manifest">customizing</a> 
      	the manifest.</p></li><li><p>Split packages (i.e. classes from the same package can come from different bundles) are not supported.</p><p> 
      	This means that packages present in the test framework are considered complete and no <code class="code">Import-Package</code> entry will be generated for them. 
      	To avoid this problem, consider using sub-packages or moving the classes inside one bundle. Note that split packages are discouraged due to the
      	issues associated with them (see the OSGi Core spec, Chapter 3.13 - Required Bundles).</p></li><li><p>The test bundle contains only test classes.</p><p>The byte-code parser will look only at the test classes hierarchy. Any other class included in the bundle, will not be considered so no imports
      	will be generated for it. Consider customizing the manifest yourself or attaching the extra code as inner classes to the test class. A future version
      	of Spring-DM might alleviate this problem by inspecting all classes included in the test bundle.</p></li></ul></div><p>
      The reason behind <span class="emphasis"><em>the lack of such features</em></span> is the byte-code parser is aimed to be simple and fast at creating test manifests - 
      it is not meant as a general-purpose tool for creating OSGi artifacts.  
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="testing:integration:appContext"></a>7.2.4.&nbsp;Creating an OSGi application context</h3></div></div></div><p>Spring-DM testing suite builds on top of Spring testing classes. To create an application context
	  (OSGi specific), one should just override <code class="literal">getConfigLocations[]</code> method and indicate
	  the location of the application context configuration. At runtime, an OSGi application context will be created
	  and cached for the lifetime of the test case.</p><pre class="programlisting">protected String[] getConfigLocations() {
   return new String[] { "/com/xyz/abc/test/MyTestContext.xml" };
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="testing:integration:specify-platform"></a>7.2.5.&nbsp;Specifying the OSGi platform to use</h3></div></div></div><p>The testing framework supports out of the box, three OSGi 4.0 implementations namely:
      Equinox, Knopflerfish and Felix. To be used, these should be in the test classpath. By default,
      the testing framework will try to use Equinox platform. This can be configured in several ways:</p><div class="orderedlist"><ol type="1"><li><p>programmatically through <code class="literal">getPlatformName()</code> method</p>.
      <p>Override the aforementioned method and indicate the fully qualified name of
      the <code class="interfacename">Platform</code> interface implementation. Users can use the <code class="classname">Platforms</code> 
      class to specify one of the supported platforms:</p><pre class="programlisting">protected String getPlatformName() {
   return Platforms.FELIX;
}</pre></li><li><p>declaratively 
      through <code class="literal">org.springframework.osgi.test.framework</code> system property.</p><p>If this property is set, 
      the testing framework will use its value as a fully qualified name of a Platform implementation. 
      It that fails, it will fall back to Equinox after logging a warning message.
      This option is useful for building tools (such as ant or maven) since it indicates a certain
      target environment without changing and test code.</p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="testing:integration:specify-test-wait-time"></a>7.2.6.&nbsp;Waiting for the test dependencies</h3></div></div></div><p>A built-in feature of the testing framework is the ability to wait until all dependencies are deployed before
      starting the test execution. Since the OSGi platforms are concurrent by nature, installing a bundle doesn't mean that
      all its services are running. By running a test before its dependency services are fully initialized can cause sporadic
      errors that pollute the test results. By default, the testing framework inspects all bundles installed by the user and,
      if they are Spring-powered bundles, waits until they are fully started (that is their application context is published
      as an OSGi service). This behaviour can be disabled by overriding <code class="literal">shouldWaitForSpringBundlesContextCreation</code>
      method. Consult <code class="classname">AbstractSynchronizedOsgiTests</code> for more details.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="testing:integration:performance"></a>7.2.7.&nbsp;Testing framework performance</h3></div></div></div><p>Considering all the functionality offered by the testing framework, one might wonder if this doesn't become a 
      performance bottleneck. First, it's worth noting that all the work done automatically by the testing infrastructure 
      has to be done anyway (such as creating the manifest or creating a bundle for the test or installing the bundles).
      Doing it manually simply simply does not work as it's too error prone and time consuming. 
      In fact, the current infrastructure started as way to do efficient, automatic testing without worrying 
      about deployment problems and redundancy.</p><p>As for the numbers, the current infrastructure has been used internally for the last half a year - our integration tests
      (around 120) run in about 3:30 on a laptop. Most of this time is spent on starting and stopping the OSGi platform: the "testing 
      framework" takes around 10% (as shown in our profiling so far).
      For example, the manifest generation has proved to take less then 0.5 seconds in general, while the jar creation around 1
      second.</p><p>However, we are working on making it even faster and smarter so that less configuration options are needed and
      the contextual information available in your tests is used as much as possible. If you have any ideas or suggestion,
      feel free to use our issue tracker or/and mailing list.     
      </p></div><p>Hopefully this chapter showed how Spring-DM testing infrastructure can simplify OSGi integration testing and 
    how it can be customized. Consider consulting the javadocs for more information.
    </p></div></div></div><div class="part" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="appendixes"></a>Part&nbsp;III.&nbsp;Appendixes</h1></div></div></div><div class="partintro" lang="en"><div><div><div><h1 class="title"><a name="d30e3405"></a>Document structure</h1></div></div></div><p>
	  Various appendixes outside the reference documentation.
      </p><p><a href="#appendix-compendium" title="Appendix&nbsp;A.&nbsp;Compendium Services">Appendix&nbsp;A, <i xmlns:xlink="http://www.w3.org/1999/xlink">Compendium Services</i></a> describes the support provided
      for the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www2.osgi.org/Release4/Download" target="_top">OSGi
      Compendium Services</a>, including the Configuration Admin
      service. While the support is included in the 1.0 distribution, it is not 
      guaranteed (yet) to be maintained in a backward-compatible form in future point 
      releases.</p><p><a href="#appendix-extensions" title="Appendix&nbsp;B.&nbsp;Extensions">Appendix&nbsp;B, <i xmlns:xlink="http://www.w3.org/1999/xlink">Extensions</i></a> describes extensions that are included in
      the 1.0 distribution, but are not guaranteed to be maintained in a
      backward-compatible form in future point releases. We anticipate these
      features moving into the core specification over time.</p><p><a href="#appendix-pde-integration" title="Appendix&nbsp;C.&nbsp;Eclipse Plug-in Development integration">Appendix&nbsp;C, <i xmlns:xlink="http://www.w3.org/1999/xlink">Eclipse Plug-in Development integration</i></a> describes how to integrate Spring-DM
      with Eclipse Plug-in Development Environment.</p><p><a href="#appendix-archetype" title="Appendix&nbsp;D.&nbsp;Spring Dynamic Modules Maven Archetype">Appendix&nbsp;D, <i xmlns:xlink="http://www.w3.org/1999/xlink">Spring Dynamic Modules Maven Archetype</i></a> describes the Spring-DM Maven 2 archetype
      usage.</p><p><a href="#appendix-roadmap" title="Appendix&nbsp;E.&nbsp;Roadmap">Appendix&nbsp;E, <i xmlns:xlink="http://www.w3.org/1999/xlink">Roadmap</i></a> describes some features that are included in
      the 1.0 distribution but are still considered early-access. The
      externals of these features may change in future releases. This appendix
      also discusses other planned features for which no implementation yet
      exists.</p><p><a href="#appendix-schema" title="Appendix&nbsp;F.&nbsp;Spring Dynamic Modules Schema">Appendix&nbsp;F, <i xmlns:xlink="http://www.w3.org/1999/xlink">Spring Dynamic Modules Schema</i></a> defines the schemas provided by Spring Dynamic
      Modules.</p></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="appendix-compendium"></a>Appendix&nbsp;A.&nbsp;Compendium Services</h2></div></div></div><p>The OSGi Service Platform Service Compendium specification defines a
    number of additional services that may be supported by OSGi
    implementations. Spring Dynamic Modules supports an additional
    "compendium" namespace that provides support for some of these services.
    By convention, the prefix <code class="literal">osgix</code> is used for this
    namespace.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans:beans xmlns="http://www.springframework.org/schema/osgi"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:osgix="http://www.springframework.org/schema/osgi-compendium"
   xmlns:beans="http://www.springframework.org/schema/beans"
   xsi:schemaLocation="http://www.springframework.org/schema/osgi  
        http://www.springframework.org/schema/osgi/spring-osgi.xsd
        http://www.springframework.org/schema/osgi-compendium
        http://www.springframework.org/schema/osgi-compendium/spring-osgi-compendium.xsd
        http://www.springframework.org/schema/beans   
        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

   &lt;!-- use the OSGi namespace elements directly --&gt;
   &lt;service id="simpleServiceOsgi" ref="simpleService"
       interface="org.xyz.MyService" /&gt;

   &lt;!-- qualify compendium namespace elements --&gt;
   &lt;osgix:property-placeholder persistent-id="com.xyz.myapp"/&gt;

&lt;/beans:beans&gt;</pre><p>At present this namespace provides support for the Configuration
    Admin service. Support for other compendium services may be added in
    future releases.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="compendium:cm"></a>A.1.&nbsp; Configuration Admin</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="compendium:cm:ppc"></a>A.1.1.&nbsp;Property placeholder support</h3></div></div></div><div class="sidebar"><p class="title"><b>Future directions</b></p><p>Please note that in future releases, the property-placeholder
		  element will be changed to be properly align with Spring Framework
		  classes and namespace. That is, rather then provide a Spring-DM
		  specific declaration, the <span class="emphasis"><em>traditional</em></span> Spring
		  Framework declaration can be used.
		  </p></div><p>Spring Dynamic Modules provides support for sourcing bean
        property values from the OSGi Configuration Administration service.
        This support is enabled via the
        <code class="literal">property-placeholder</code> element. The property
        placeholder element provides for replacement of delimited string
        values (placeholders) in bean property expressions with values sourced
        from the configuration administration service. The required
        <code class="literal">persistent-id</code> attribute specifies the persistent
        identifier to be used as the key for the configuration dictionary. The
        default delimiter for placeholder strings is "${...}".</p><p>Given the declarations:</p><pre class="programlisting">&lt;osgix:property-placeholder persistent-id="com.xyz.myapp"/&gt;

&lt;bean id="someBean" class="AClass"&gt;
  &lt;property name="timeout" value="${timeout}"/&gt;
&lt;/bean&gt;</pre><p>Then the <code class="literal">timeout</code> property of
        <code class="literal">someBean</code> will be set using the value of the
        <code class="literal">timeout</code> entry in the configuration dictionary
        registered under the <code class="literal">com.xyz.myapp</code> persistent
        id.</p><p>The placeholder strings are evaluated at the time that the bean
        is instantiated. Changes to the properties made via Configuration
        Admin subsequent to the creation of the bean do
        <span class="emphasis"><em>not</em></span> result in re-injection of property values.
        See the <code class="literal">managed-service</code> and
        <code class="literal">managed-service-reference</code> elements documented in
        appendix B if you require this level of integration. The
        <code class="literal">placeholder-prefix</code> and
        <code class="literal">placeholder-suffix</code> attributes can be used to change
        the delimiter strings used for placeholder values.</p><p>It is possible to specify a default set of property values to be
        used in the event that the configuration dictionary does not contain
        an entry for a given key. The <code class="literal">defaults-ref</code>
        attribute can be used to refer to a named bean of
        <code class="literal">Properties</code> or <code class="interfacename">Map</code> type. Instead
        of referring to an external bean, the
        <code class="literal">default-properties</code> nested element may be used to
        define an inline set of properties.</p><pre class="programlisting">&lt;osgix:property-placeholder persistent-id="com.xyz.myapp"&gt;
  &lt;default-properties&gt; 
     &lt;property name="productCategory" value="E792"/&gt;
     &lt;property name="businessUnit" value="811"/&gt; 
  &lt;/default-properties&gt;
&lt;/osgix:property-placeholder&gt;</pre><p>The <code class="literal">persistent-id</code> attribute must refer to the
        persistent-id of an OSGi <code class="interfacename">ManagedService</code>, it is a
        configuration error to specify a factory persistent id referring to a
        <code class="interfacename">ManagedServiceFactory</code>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="compendium:cm:dict"></a>A.1.2.&nbsp;Configuration Dictionaries</h3></div></div></div><p>Support for directly accessing configuration objects and their
        associated dictionaries, and for instantiating beans directly from
        configuration objects is on the Spring Dynamic Modules road map. See
        <a href="#appendix-roadmap" title="Appendix&nbsp;E.&nbsp;Roadmap">Appendix&nbsp;E, <i xmlns:xlink="http://www.w3.org/1999/xlink">Roadmap</i></a> for more information.</p></div></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="appendix-extensions"></a>Appendix&nbsp;B.&nbsp;Extensions</h2></div></div></div><p>This appendix describes extensions to the core functionality that
    are shipped with the 1.0 distribution, but are not guaranteed to have
    backwards compatibility across point releases. We anticipate these
    features migrating into the core specification in future releases.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d30e3539"></a>B.1.&nbsp;Annotation-based injection</h2></div></div></div><p>The
      <code class="literal">org.springframework.osgi.extensions.annotation</code> bundle
      that ships with Spring Dynamic Modules provides early access to
      annotation-based support for injecting references to OSGi services. JDK
      1.5 or above is required to use this feature.</p><p>Bean class (setter) methods may be annotated with
      <code class="literal">org.springframework.osgi.extensions.annotation.ServiceReference</code>.
      By default the property type of the annotated property is used to look
      up a service with a matching service interface in the OSGi service
      registry and inject the result. For example, given the
      configuration:</p><pre class="programlisting">&lt;bean id="annotationDriven" class="MyAnnotationDrivenBeanClass"&gt;
      </pre><p>and the class declaration:</p><pre class="programlisting">public class MyAnnotationDrivenBeanClass {

  @ServiceReference
  public void setMessageService(MessageService aService) { ... }

}</pre><p>then a service lookup for services implementing the
      <code class="interfacename">MessageService</code> interface will be performed, and the
      best match (using the same algorithm as documented for the
      <code class="literal">reference</code> element) will be injected.</p><p>The <code class="classname">ServiceReference</code> annotation class has a
      number of attributes that can be used to control the service lookup (for
      example, to specify a filter string) that mirror the options provided by
      the <code class="literal">reference</code> element. See the javadoc for more
      information.</p></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="appendix-pde-integration"></a>Appendix&nbsp;C.&nbsp;Eclipse Plug-in Development integration</h2></div></div></div><p>Eclipse <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.eclipse.org/pde/" target="_top">PDE</a> &#8220;<span class="quote">provides comprehensive OSGi tooling, which makes it 
    an ideal environment for component programming, not just Eclipse plug-in development</span>&#8221;.
    In fact, Eclipse IDE is built on top of OSGi and uses at its core the Equinox OSGi implementation. Moreover, all the Eclipse 
    plug-ins are OSGi bundles. This makes Eclipse with PDE a very attractive tool for creating OSGi bundles.
    While Spring Dynamic Modules artifacts can be integrated as <span class="emphasis"><em>normal</em></span> libraries, through 
    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.springide.org" target="_top">Spring IDE</a>, Spring-DM can be installed as a 
    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://help.eclipse.org/stable/index.jsp?topic=/org.eclipse.pde.doc.user/guide/tools/preference_pages/target_platform.htm" target="_top">
    target platform</a> ready to be used with PDE.
   </p><div class="procedure"><p>The following steps illustrate how to install Spring IDE extension for OSGi and how to use it in your project. Please see 
     <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://springide.org/project/wiki/SpringideInstall" target="_top">Spring IDE installation page</a> for information on its requirement
     and install process.</p><ol type="1"><li><p class="title"><b>Set up nightly update site</b></p><p>At the moment, the OSGi extension is available only on Spring-IDE nightly builds update site. Add it to the Eclipse configuration by
   	 	opening the software update menu:
   	 	</p><p>
		  </p><div class="mediaobject" align="left"><img src="images/pde/find-install.png" align="left"></div><p>
          
		  </p><div class="mediaobject" align="central"><img src="images/pde/springide-site.png" align="central"></div><p>        
          
        </p><p>and create a new update site pointing to <code class="literal">http://www.springide.org/updatesite_nightly</code></p></li><li><p class="title"><b>Select Spring IDE OSGi extension</b></p><p>After using the nightly update site and performing the update, Eclipse will show the search results. Unfold the <span class="emphasis"><em>Extension</em></span> menu and select <code class="literal">Spring IDE OSGi Extension</code>:</p><p>
		  </p><div class="mediaobject" align="center"><img src="images/pde/spring-osgi-plugin.png" align="middle" alt="Select Spring IDE OSGI extension"></div><p>        
        </p><p>and proceed with the instalation.</p></li><li><p class="title"><b>Select Spring Dynamic Modules Target Platform</b></p><p>Once the plug-in has been installed, Spring Dynamic Modules can be selected as a PDE target platform. Select Window/Preferences/Plug-in Development and then
   	 	Target Platform.</p><p>
		  </p><div class="mediaobject" align="center"><img src="images/pde/target-select.png" align="middle" alt="Select Spring-DM target platform"></div><p>
        </p><p>Select the Spring-DM version that you desire from the Pre-defined Target (1) drop box and press Load Target (2). Eclipse will load the target and all bundles defined
        by it - this includes Spring-DM bundles and all of its dependencies (SLF4J is used for logging). The configuration can be customised appropriately by removing
        and adding bundles.</p><p>In its current form, the plug-in offers two predefined targets - one for the stable released versions and one for the SNAPSHOT/nightly Spring DM jars. The latter
        does not contain any jars as it is expected for the user to download them manually. Simply locate the path where the plug-ins should be located (3), enter that folder 
        and do a </p><pre class="programlisting">mvn install</pre><p>The latest Spring-DM SNAPSHOT will be downloaded along with all of its dependencies.
        Simply click on the reload button (4) and Eclipse will pick up the bundles. </p></li><li><p class="title"><b>Select PDE perspective</b></p><p>Once the installation is completed just select the PDE perspective:</p><p>
		  <span class="inlinemediaobject"><img src="images/pde/select-pde-1.png" align="left"></span>
		  <span class="inlinemediaobject"><img src="images/pde/select-pde-2.png" align="central"></span>
          
        </p><p>and the Spring-DM and its dependencies should be available in the plug-ins view:</p><p>
		  <span class="inlinemediaobject"><img src="images/pde/select-plugins-view.png" align="left"></span>

		  <span class="inlinemediaobject"><img src="images/pde/show-plugins.png" align="central"></span>          
        </p></li></ol></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="appendix-archetype"></a>Appendix&nbsp;D.&nbsp;Spring Dynamic Modules Maven Archetype</h2></div></div></div><p>As part of the distribution, Spring-DM provides a Maven <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://maven.apache.org/plugins/maven-archetype-plugin/" target="_top">archetype</a>
    which creates the basic structure of a Java project that uses Spring DM, especially useful to new users. To run the archetype (and create the new project),
    simply run the following command line:</p><pre class="programlisting">mvn archetype:create \
-DarchetypeGroupId=org.springframework.osgi \
-DarchetypeArtifactId=spring-osgi-bundle-archetype \
-DarchetypeVersion=${version}   \
-DgroupId=&lt;your-project-groupId&gt;  \
-DartifactId=&lt;your-project-artifactId&gt; \
-Dversion=&lt;your-project-version&gt; 
   </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>The command above should be invoked as one line - the <code class="literal">\</code> is used as a convenience to break the long line into smaller pieces</div><p>The result of the command, is a Maven 2 project that defines a simple bean, configures it using 
    <code class="literal">src/main/resources/META-INF/spring/bundle-context.xml</code> and <code class="literal">src/main/resources/META-INF/spring/bundle-context-osgi.xml</code> 
    and provides unit and (out of the OSGi container) integration tests. The project is packaged as an OSGi bundle.</p><p>Notice that by default, the project does not contain a MANIFEST.MF for your project. The Maven infrastructure will generate it, through Apache
    Felix <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://felix.apache.org/site/maven-bundle-plugin-bnd.html" target="_top">bundle plug-in</a>. To do that, run the following (from the project root):</p><pre class="programlisting">mvn package</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>To avoid the confusion between the generated artifacts and maintained files, the manifest file resides under <code class="literal">META-INF</code> folder
    while Spring configuration files under <code class="literal">src/main/resources/META-INF</code> directory.</div><p>This will compile your project, pack it as a jar and create the OSGi manifest based on your classes under <code class="literal">/META-INF</code> folder (so
    that users running Eclipse PDE can use it right away. To generate the manifest, without creating the OSGi bundle, simply run: 
    </p><pre class="programlisting">mvn org.apache.felix:maven-bundle-plugin:manifest</pre><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="archetype:generated-content"></a>D.1.&nbsp;Generated Project Features at-a-glance</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li>Packaged as an OSGi bundle</li><li><code class="literal">META-INF/MANIFEST.MF</code> for OSGi bundle automatically generated</li><li>Simple bean interface and implementation defined. Interface and implementation types are in different packages, only the interface package 
   		is exported by the bundle.</li><li><code class="literal">src/main/resources/META-INF/spring/bundle-context.xml</code> is a Spring configuration file that defines the simple bean.</li><li><code class="literal">src/main/resources/META-INF/spring/bundle-context-osgi.xml</code> is a spring configuration file ready for you to add bean 
   		definitions from the osgi namespace (services, references etc.)</li><li><code class="literal">BeanImplTest</code> case defined to unit test the simple bean</li><li><code class="literal">BeanIntegrationTest</code> defined to fire up the non-osgi portions of the application context configuration and test 
   		<span class="emphasis"><em>outside</em></span> of OSGi</li><li><code class="literal">BeanOgiIntegrationTest</code> defined to fire up the osgi portions of the application context configuration and test 
   		<span class="emphasis"><em>inside</em></span> of OSGi</li><li><code class="literal">.project</code>, <code class="literal">.classpath</code>, and <code class="literal">build.properties</code> files created to enable use of this 
   		project directly inside eclipse as a PDE plugin project</li></ul></div></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="appendix-roadmap"></a>Appendix&nbsp;E.&nbsp;Roadmap</h2></div></div></div><p>
		This appendix documents features on the Spring Dynamic Modules
		roadmap. The design of these features specified here is subject
		to change. As a most up to date source, please see
		<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jira.springframework.org/browse/OSGI" target="_top">
			our
		</a>
		issue tracker.
	</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d30e3807"></a>E.1.&nbsp;Enhanced Configuration Admin Support</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d30e3810"></a>E.1.1.&nbsp;Managed Services</h3></div></div></div><p>
				It should be possible to easily instantiate a bean from
				the configuration information stored for a
				<code class="literal">ManagedService</code>
				, and a set of beans from the configuration information
				stored for a
				<code class="literal">ManagedServiceFactory</code>
				. In addition, updates to the configuration information
				should be propagated to beans created in this way.
			</p><p>
				The
				<code class="literal">managed-service</code>
				element is used to define a bean based on the
				configuration information stored under a given
				persistent id. It has two mandatory attributes,
				<code class="literal">class</code>
				and
				<code class="literal">persistent-id</code>
				. The
				<code class="literal">persistent-id</code>
				attribute is used to specify the persistent id to be
				looked up in the configuration administration service,
				<code class="literal">class</code>
				indicates the Java class of the bean that will be
				instantiated.
			</p><p>
				A simple declaration of a managed service bean would
				look as follows:
			</p><pre class="programlisting">&lt;osgix:managed-service id="myService" class="com.xyz.MessageService" 
   persistent-id="com.xyz.messageservice"/&gt;</pre><p>The properties of the <code class="literal">managed-service</code> bean
        are autowired by name based on the configuration found under the given
        persistent id. It is possible to declare regular Spring bean
        <code class="literal">property</code> elements within the
        <code class="literal">managed-service</code> declaration. If a property value is
        defined both in the configuration object stored in the Configuration
        Admin service, and in a nested <code class="literal">property</code> element,
        then the value from Configuration Admin takes precedence. Property
        values specified via <code class="literal">property</code> elements can
        therefore be treated as default values to be used if none is available
        through Configuration Admin.</p><p>It is possible for the configuration data stored in
        Configuration Admin to be updated once the bean has been created. By
        default, any updates post-creation will be ignored. To receive
        configuration updates, the <code class="literal">update-strategy</code>
        attribute can be used with a value of either
        <code class="literal">bean-managed</code> or
        <code class="literal">container-managed</code>.</p><p>The default value of the optional
        <code class="literal">update-strategy</code> attribute is
        <code class="literal">none</code>. If an update strategy of
        <code class="literal">bean-managed</code> is specified then the
        <code class="literal">update-method</code> attribute must also be used to
        specify the name of a method defined on the bean class that will be
        invoked if the configuration for the bean is updated. The update
        method must have one of the following signatures:</p><pre class="programlisting">public void anyMethodName(Map properties)
public void anyMethodName(Map&lt;String,?&gt; properties); // for Java 5
public void anyMethodName(Dictionary properties);</pre><p>When an update strategy of <code class="literal">container-managed</code>
        is specified then the container will autowire the bean instance by
        name based on the new properties received in the update. For
        <code class="literal">container-managed</code> updates, the bean class must
        provide setter methods for the bean properties that it wishes to have
        updated. Container-managed updates cannot be used in conjunction with
        constructor injection. Before proceeding to autowire based on the new
        property values, a lock is taken on the bean instance. This lock is
        released once autowiring has completed. A class may therefore
        synchronize its service methods or otherwise lock on the bean instance
        in order to have atomic update semantics.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d30e3894"></a>E.1.2.&nbsp;Managed Service Factories</h3></div></div></div><p>The <code class="literal">managed-service-factory</code> element is
        similar to the <code class="literal">managed-service</code> element, but instead
        defines a set of beans, one instance for each configuration stored
        under the given factory pid. It has two mandatory attributes,
        <code class="literal">factory-pid</code> and <code class="literal">class</code>.</p><p>A simple <code class="literal">managed-service-factory</code> declaration
        would look as follows:</p><pre class="programlisting">&lt;osgix:managed-service-factory id="someId" factory-pid="org.xzy.services" 
           class="MyServiceClass"/&gt;</pre><p>This declaration results in the creation of zero or more beans,
        one bean for each configuration registered under the given factory
        pid. The beans will have synthetic names generated by appending "-"
        followed by the persistent id of the configuration object as returned
        by Configuration Admin, to the value of the <code class="literal">id</code>
        attribute used in the declaration of the
        <code class="literal">managed-service-factory</code>. For example,
        <code class="literal">someId-config.admin.generated.pid</code>.</p><p>Over time new configuration objects may be added under the
        factory pid. A new bean instance is automatically instantiated
        whenever a new configuration object is created. If a configuration
        object stored under the factory pid is deleted, then the corresponding
        bean instance will be disposed (this includes driving the
        <code class="literal">DisposableBean</code> callback if the bean implements
        <code class="literal">DisposableBean</code>). The option
        <code class="literal">destroy-method</code> attribute of the
        <code class="literal">managed-service-factory</code> element may be used to
        specify a destroy callback to be invoked on the bean instance. Such a
        method must have a signature:</p><pre class="programlisting">public void anyMethodName();</pre><p>It is also possible for the configuration of an existing bean to
        be updated. The same <code class="literal">update-strategy</code> and
        <code class="literal">update-method</code> attributes are available as for the
        <code class="literal">managed-service</code> element and with the same semantics
        (though obviously only the bean instance whose configuration has been
        updated in Configuration Admin will actually be updated). The same
        client-locking semantics also apply when using the
        <code class="literal">container-managed</code> update strategy</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d30e3959"></a>E.1.3.&nbsp;Direct access to configuration data</h3></div></div></div><p>If you need to work directly with the configuration data stored
        under a given persistent id or factory persistent id, the easiest way
        to do this is to register a service that implements either the
        <code class="literal">ManagedService</code> or
        <code class="literal">ManagedServiceFactory</code> interface and specify the pid
        that you are interested in as a service property. For example:</p><pre class="programlisting">&lt;service interface="org.osgi.service.cm.ManagedService" ref="MyManagedService"&gt;
  &lt;service-properties&gt;
    &lt;entry key="service.pid" value="my.managed.service.pid"/&gt;
  &lt;/service-properties&gt;
&lt;/service&gt;

&lt;bean id="myManagedService" class="com.xyz.MyManagedService"/&gt;</pre><p>and where the class <code class="literal">MyManagedService</code>
        implements
        <code class="literal">org.osgi.service.cm.ManagedService</code>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d30e3980"></a>E.1.4.&nbsp;Publishing configuration administration properties with
        exported services</h3></div></div></div><p>We intend to provide support for automatic publication of
        service properties sourced from the Configuration Admin service under
        a given persistent id. This support has yet to be designed but may
        look as follows:</p><pre class="programlisting">&lt;service ref="toBeExported" interface="SomeInterface"&gt;
   &lt;osgix:config-properties persistent-id="pid"/&gt;
&lt;/service&gt;</pre><p>Issues to be considered are scoping of a subset of properties to
        be published (public/private), and automatic updates to published
        service properties if the value is updated via config admin.</p><p>Note that named properties can easily be published as service
        properties already without this support, simply by using the
        <code class="literal">property-placeholder</code> support.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d30e3994"></a>E.2.&nbsp;Access to Service References for Collections</h2></div></div></div><p>The current specification does not provide for access to the
      <code class="literal">ServiceReference</code> objects for services in a managed
      collection (i.e. obtained via a <code class="literal">set</code> or
      <code class="literal">list</code> declaration). A future release of Spring Dynamic
      Modules will provide an easy means of gaining access to these
      references.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d30e4008"></a>E.3.&nbsp;Start level integration</h2></div></div></div><p>A future release of Spring Dynamic Modules may offer the following
      additional guarantee with respect to application context creation and
      start levels:</p><p>Application context creation happens asynchronously. However, the
      extender bundle does guarantee that the creation of all application
      contexts for bundles at start level <code class="literal">n</code> will be
      complete before the creation of any application context at start level
      <code class="literal">m</code>, where <code class="literal">m &gt; n</code>. Care must
      therefore be taken not to introduce any mandatory dependencies on
      services exported by bundles with higher start levels or a deadlock will
      be introduced.</p><p>In a similar vein, when shutting down the extender bundle,
      application contexts at start level <code class="literal">m</code> will be shut
      down before application contexts at start level <code class="literal">n</code>,
      where <code class="literal">m &gt; n</code>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d30e4035"></a>E.4.&nbsp;Web application support</h2></div></div></div><p>A key part of the roadmap for the next release of Spring Dynamic
      Modules is built-in support for building web applications out of OSGi
      bundles. This will be supported using both an <code class="interfacename">HttpService</code> 
      provided by a bundle installed into the running OSGi framework, and also by embedding
      an OSGi container inside an existing servlet container. Pioneering work
      has been done by <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://martinlippert.blogspot.com/2007/06/slides-and-examples-from-springone-2007.html" target="_top">Martin
      Lippert</a>, <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://thegoodthebadtheugly.wordpress.com/2007/05/20/springosgi/" target="_top">Bernd
      Kolb</a>, and Gerd Wutherich amongst others. Please see our mailing list archive
      for more information.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d30e4049"></a>E.5.&nbsp;ORM/Persistence support</h2></div></div></div><p>Care needs to be taken when using JPA or Hibernate under OSGi as
      the persistence engines must have visibility of the persistent types and
      mapping files. The Spring Dynamic Modules project will be investigating
      an extension model to make managing this easier when persistent
      configuration is split across several bundles. See Peter Krien's <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.osgi.org/blog/2007/06/osgi-and-hibernate.html" target="_top">blog
      entry</a> on the topic for an insight into the issues.</p><p>Also, the project aims to simplify deployment of JDBC drivers and
      pooling libraries that at the moment require special <code class="literal">DynamicImport-Package</code>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d30e4062"></a>E.6.&nbsp;OSGi standards</h2></div></div></div><p>While OSGi 4.0 is currently required, work is underway to take advantage of the
	  new features available in 4.1. SpringSource is an active participant in the 
	  <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www2.osgi.org/EEG/HomePage" target="_top">OSGi Enterprise Expert Group</a> 
	  and we hope to help many of the ideas found in the Spring Dynamic Modules project 
	  to make their way into the OSGi R5 specification.
	  Spring Dynamic Modules would obviously seek to support any such standards at that 
	  point in time.</p></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="appendix-schema"></a>Appendix&nbsp;F.&nbsp;Spring Dynamic Modules Schema</h2></div></div></div><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;xsd:schema xmlns="http://www.springframework.org/schema/osgi"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            xmlns:beans="http://www.springframework.org/schema/beans"
            xmlns:tool="http://www.springframework.org/schema/tool"
            targetNamespace="http://www.springframework.org/schema/osgi"
            elementFormDefault="qualified"
            attributeFormDefault="unqualified"
            version="1.0"&gt;

    &lt;xsd:import namespace="http://www.springframework.org/schema/beans"/&gt;
    &lt;xsd:import namespace="http://www.springframework.org/schema/tool"/&gt;

    &lt;xsd:annotation&gt;
        &lt;xsd:documentation&gt;&lt;![CDATA[
            Namespace support for the core services provided by Spring Dynamic Modules.
        ]]&gt;&lt;/xsd:documentation&gt;
    &lt;/xsd:annotation&gt;
    
    &lt;xsd:attributeGroup name="defaults"&gt;
    	&lt;xsd:annotation&gt;
    		&lt;xsd:documentation&gt;&lt;![CDATA[Defaults for Spring-DM OSGi declarations.]]&gt;
    		&lt;/xsd:documentation&gt;
    	&lt;/xsd:annotation&gt;
    	&lt;!-- attributes --&gt;
    	&lt;xsd:attribute name="default-timeout" type="xsd:long" default="30000"&gt;
    		&lt;xsd:annotation&gt;
    			&lt;xsd:documentation&gt;&lt;![CDATA[
    			Default timeout (in milliseconds) for all reference (service importers) elements that do not explicitly specify one.
    			Default value is 300000 ms (5 minutes).
    			]]&gt;&lt;/xsd:documentation&gt;
    		&lt;/xsd:annotation&gt;
    	&lt;/xsd:attribute&gt;
    	&lt;xsd:attribute name="default-cardinality" type="TdefaultCardinalityOptions" default="1..X"&gt;
    		&lt;xsd:annotation&gt;
    			&lt;xsd:documentation&gt;&lt;![CDATA[
            	Default cardinality (of the relationship to the backing service(s)) for all OSGi references (singular or collections) 
            	elements that do not explicitly specify one.
            	Default value is '1..X' (resolved to '1..1' for osgi:reference and '1..N' for osgi:list/set) which means that a backing 
            	service must exist (this is a mandatory service reference). A value of '0..X' (resolved to '0..1' for osgi:reference 
            	and '0..N' for osgi:list/set) indicates that it is acceptable to be no backing service (an optional service reference).
        		]]&gt;&lt;/xsd:documentation&gt;
        	&lt;/xsd:annotation&gt;
        &lt;/xsd:attribute&gt;
    &lt;/xsd:attributeGroup&gt;
    
    &lt;xsd:simpleType name="TdefaultCardinalityOptions"&gt;
        &lt;xsd:restriction base="xsd:string"&gt;
            &lt;xsd:enumeration value="1..X"&gt;
            	&lt;xsd:annotation&gt;
            		&lt;xsd:documentation&gt;&lt;![CDATA[
            		A backing service must exist (this is a mandatory service reference).
            		]]&gt;&lt;/xsd:documentation&gt;
            	&lt;/xsd:annotation&gt;
            &lt;/xsd:enumeration&gt;
            &lt;xsd:enumeration value="0..X"&gt;
            	&lt;xsd:annotation&gt;
            		&lt;xsd:documentation&gt;&lt;![CDATA[
            		A backing service can be missing (this is an optional service reference).
            		]]&gt;&lt;/xsd:documentation&gt;
            	&lt;/xsd:annotation&gt;
            &lt;/xsd:enumeration&gt;
        &lt;/xsd:restriction&gt;
    &lt;/xsd:simpleType&gt;
	
    &lt;!-- reference --&gt;
    &lt;xsd:element name="reference" type="TsingleReference"&gt;
        &lt;xsd:annotation&gt;
            &lt;xsd:documentation&gt;&lt;![CDATA[
            Defines a reference to a service obtained via the OSGi service registry.
            ]]&gt;&lt;/xsd:documentation&gt;
        &lt;/xsd:annotation&gt;
    &lt;/xsd:element&gt;

    &lt;xsd:complexType name="Treference"&gt;
        &lt;xsd:complexContent&gt;
            &lt;xsd:extension base="beans:identifiedType"&gt;
                &lt;xsd:sequence minOccurs="0" maxOccurs="unbounded"&gt;
                	&lt;xsd:element name="interfaces" type="beans:listOrSetType" minOccurs="0" maxOccurs="1"&gt;
                    	&lt;xsd:annotation&gt;
                    		&lt;xsd:documentation&gt;&lt;![CDATA[
                    		The set of service interfaces to advertise in the service registry.
                    		]]&gt;&lt;/xsd:documentation&gt;
                    	&lt;/xsd:annotation&gt;
                    &lt;/xsd:element&gt;                
                    &lt;xsd:element name="listener" type="Tlistener" minOccurs="0" maxOccurs="unbounded"&gt;
                      &lt;xsd:annotation&gt;
                      	&lt;xsd:documentation&gt;&lt;![CDATA[
                      	  Defines a listener that will receive notification when a service backing this reference is 
                      	  bound or unbound. 
                      	]]&gt;&lt;/xsd:documentation&gt;
                      &lt;/xsd:annotation&gt;
                    &lt;/xsd:element&gt;
                &lt;/xsd:sequence&gt;
                &lt;xsd:attribute name="interface" use="optional" type="xsd:token"&gt;
                	&lt;xsd:annotation&gt;
                		&lt;xsd:documentation&gt;&lt;![CDATA[
                		The service interface that the services obtained via the registry are required to support.
                		By convention this is a Java interface type, but may also be a (non-final) class type.
                		]]&gt;&lt;/xsd:documentation&gt;
                		&lt;xsd:appinfo&gt;
                			&lt;tool:annotation&gt;
                				&lt;tool:expected-type type="java.lang.Class" /&gt;
                			&lt;/tool:annotation&gt;
                		&lt;/xsd:appinfo&gt;
                	&lt;/xsd:annotation&gt;
                &lt;/xsd:attribute&gt;
                &lt;xsd:attribute name="filter" use="optional" type="xsd:string"&gt;
                      &lt;xsd:annotation&gt;
                      	&lt;xsd:documentation&gt;&lt;![CDATA[
                      	  Defines an OSGi filter expression that is used to constrain the set of matching services
                      	  in the service registry. 
                      	]]&gt;&lt;/xsd:documentation&gt;
                      &lt;/xsd:annotation&gt;
                &lt;/xsd:attribute&gt;
                &lt;xsd:attribute name="depends-on" type="xsd:string" use="optional"&gt;
					&lt;xsd:annotation&gt;
						&lt;xsd:documentation&gt;&lt;![CDATA[
							Used to refer to the name of another bean that this bean depends on. Ensures that the
							service registry look-up does not happen until after the dependent bean has been created 
							(most commonly used to refer to a bundle bean).
						]]&gt;&lt;/xsd:documentation&gt;
					&lt;/xsd:annotation&gt;                
                &lt;/xsd:attribute&gt;
                &lt;xsd:attribute name="bean-name" type="xsd:string" use="optional"&gt;
                	&lt;xsd:annotation&gt;
                		&lt;xsd:documentation&gt;&lt;![CDATA[
                			Convenient shortcut for specifying a filter expression that matches on the bean-name property
                			that is automatically advertised for beans published using the service element.
                		]]&gt;&lt;/xsd:documentation&gt;
                	&lt;/xsd:annotation&gt;
                &lt;/xsd:attribute&gt;
                &lt;xsd:attribute name="context-class-loader" type="TreferenceClassLoaderOptions" default="client"&gt;
                	&lt;xsd:annotation&gt;
                		&lt;xsd:documentation&gt;&lt;![CDATA[
                			Defines how the context class loader is managed when invoking operations on a service
                			backing this service reference. The default value is 'client' which means that the context
                			class loader has visibility of the resources on this bundle's classpath. Alternate
                			options are 'service-provider' which means that the context class loader has visibility of 
                			resources on the bundle classpath of the bundle that exported the service, and 'unmanaged'
                			which does not do any management of the context class loader.
                		]]&gt;&lt;/xsd:documentation&gt;
                	&lt;/xsd:annotation&gt;
                &lt;/xsd:attribute&gt;
            &lt;/xsd:extension&gt;
        &lt;/xsd:complexContent&gt;
    &lt;/xsd:complexType&gt;
    
    &lt;xsd:simpleType name="TreferenceClassLoaderOptions"&gt;
        &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
            &lt;xsd:enumeration value="client"/&gt;
            &lt;xsd:enumeration value="service-provider"/&gt;
            &lt;xsd:enumeration value="unmanaged"/&gt;
        &lt;/xsd:restriction&gt;
    &lt;/xsd:simpleType&gt;

    &lt;xsd:complexType name="Tlistener"&gt;
    	&lt;xsd:annotation&gt;
    		&lt;xsd:documentation&gt;&lt;![CDATA[
    			Defines a listener that will be notified when the service backing the enclosing service reference element is bound or 
    			unbound. Use either the 'ref' attribute or a nested bean declaration for the listener bean.
    		]]&gt;&lt;/xsd:documentation&gt;
    	&lt;/xsd:annotation&gt;
        &lt;xsd:sequence minOccurs="0" maxOccurs="1"&gt;
            &lt;!-- nested bean declaration --&gt;
            &lt;xsd:any namespace="##other" minOccurs="1" maxOccurs="1" processContents="skip"/&gt;
        &lt;/xsd:sequence&gt;

        &lt;!-- shortcut for bean references --&gt;
        &lt;xsd:attribute name="ref" type="xsd:string" use="optional"&gt;
        	&lt;xsd:annotation&gt;
        		&lt;xsd:documentation&gt;&lt;![CDATA[
        			Refers by name to the bean that will receive bind and unbind events
        		]]&gt;&lt;/xsd:documentation&gt;
        	&lt;/xsd:annotation&gt;
        &lt;/xsd:attribute&gt;
        &lt;xsd:attribute name="bind-method" type="xsd:token" use="optional"&gt;
        	&lt;xsd:annotation&gt;
        		&lt;xsd:documentation&gt;&lt;![CDATA[
        			The name of the method to be invoked when a backing service is bound.
        		]]&gt;&lt;/xsd:documentation&gt;
        	&lt;/xsd:annotation&gt;
        &lt;/xsd:attribute&gt;
        &lt;xsd:attribute name="unbind-method" type="xsd:token" use="optional"&gt;
        	&lt;xsd:annotation&gt;
        		&lt;xsd:documentation&gt;&lt;![CDATA[
        			The name of the method to be invoked when a backing service is unbound.
        		]]&gt;&lt;/xsd:documentation&gt;
        	&lt;/xsd:annotation&gt;
        &lt;/xsd:attribute&gt;
    &lt;/xsd:complexType&gt;
    
    &lt;!-- single reference --&gt;
    &lt;xsd:complexType name="TsingleReference"&gt;
        &lt;xsd:complexContent&gt;
            &lt;xsd:extension base="Treference"&gt;
                 &lt;xsd:attribute name="cardinality" use="optional" type="TsingleReferenceCardinality"&gt;
                	&lt;xsd:annotation&gt;
                      	&lt;xsd:documentation&gt;&lt;![CDATA[
                      	  Defines the required cardinality of the relationship to the backing service. If not specified, 
                      	  the default-cardinality attribute will apply. A value is '1..1' means that a backing service 
                      	  must exist (this is a mandatory service reference). A value of '0..1' indicates that it is 
                      	  acceptable to be no backing service (an optional service reference).
                      	]]&gt;&lt;/xsd:documentation&gt;
                      &lt;/xsd:annotation&gt;
                &lt;/xsd:attribute&gt;
				&lt;xsd:attribute name="timeout" use="optional" type="xsd:long"&gt;
                    &lt;xsd:annotation&gt;
                      	&lt;xsd:documentation&gt;&lt;![CDATA[
                      	  For a 'reference' element, the amount of time (in milliseconds) to wait for a backing service to be 
                      	  available when an operation is invoked. If not specified, the default-timeout attribute will apply.
                      	  See also the default-timeout attribute of the osgi element.
                      	]]&gt;&lt;/xsd:documentation&gt;
                      &lt;/xsd:annotation&gt;
                &lt;/xsd:attribute&gt;
            &lt;/xsd:extension&gt;
        &lt;/xsd:complexContent&gt;
   &lt;/xsd:complexType&gt;
   
   &lt;xsd:simpleType name="TsingleReferenceCardinality"&gt;
        &lt;xsd:restriction base="xsd:token"&gt;
            &lt;xsd:enumeration value="1..1"/&gt;
            &lt;xsd:enumeration value="0..1"/&gt;
        &lt;/xsd:restriction&gt;
   &lt;/xsd:simpleType&gt;

	&lt;!-- reference collections (set, list) --&gt;
	&lt;xsd:element name="list" type="TreferenceCollection"&gt;
		&lt;xsd:annotation&gt;
			&lt;xsd:documentation source="java:org.springframework.osgi.service.importer.support.OsgiServiceCollectionProxyFactoryBean"&gt;&lt;![CDATA[
			  Defines a bean of type 'List' that contains all of the services matching the given criteria.
			  The list members are managed dynamically as matching backing services come and go.
			]]&gt;&lt;/xsd:documentation&gt;
			&lt;xsd:appinfo&gt;
				&lt;tool:annotation&gt;
					&lt;tool:exports type="java.util.List"/&gt;
				&lt;/tool:annotation&gt;
			&lt;/xsd:appinfo&gt;			
		&lt;/xsd:annotation&gt;
	&lt;/xsd:element&gt;

	&lt;xsd:element name="set" type="TreferenceCollection"&gt;
		&lt;xsd:annotation&gt;
			&lt;xsd:documentation source="java:org.springframework.osgi.service.importer.support.OsgiServiceCollectionProxyFactoryBean"&gt;&lt;![CDATA[
			  Defines a bean of type 'Set' that contains all of the services matching the given criteria.
			  The set members are managed dynamically as matching backing services come and go.
			]]&gt;&lt;/xsd:documentation&gt;
			&lt;xsd:appinfo&gt;
				&lt;tool:annotation&gt;
					&lt;tool:exports type="java.util.Set"/&gt;
				&lt;/tool:annotation&gt;
			&lt;/xsd:appinfo&gt;			
		&lt;/xsd:annotation&gt;
	&lt;/xsd:element&gt;

	&lt;xsd:complexType name="TreferenceCollection"&gt;
		&lt;xsd:complexContent&gt;
			&lt;xsd:extension base="Treference"&gt;
				&lt;xsd:sequence minOccurs="0" maxOccurs="1"&gt;
					&lt;xsd:element name="comparator" type="Tcomparator"&gt;
						&lt;xsd:annotation&gt;
							&lt;xsd:documentation source="java:java.util.Comparator"&gt;&lt;![CDATA[
							  Used to define an inline bean of type Comparator that will be used to sort the matching services.
							]]&gt;&lt;/xsd:documentation&gt;
							&lt;xsd:appinfo&gt;
								&lt;tool:annotation&gt;
									&lt;tool:expected-type type="java.util.Comparator" /&gt;
  								&lt;/tool:annotation&gt;
							&lt;/xsd:appinfo&gt;
						&lt;/xsd:annotation&gt;
					&lt;/xsd:element&gt;
				&lt;/xsd:sequence&gt;
				&lt;xsd:attribute name="comparator-ref" type="xsd:string" use="optional"&gt;
					&lt;xsd:annotation&gt;
						&lt;xsd:documentation&gt;&lt;![CDATA[
							Used to refer to a named bean implementing the Comparator interface that will be used to 
							sort the matching services.
						]]&gt;&lt;/xsd:documentation&gt;
					&lt;/xsd:annotation&gt;
				&lt;/xsd:attribute&gt;
			
			    &lt;xsd:attribute name="cardinality" use="optional" type="TcollectionCardinality"&gt;
                	&lt;xsd:annotation&gt;
                      	&lt;xsd:documentation&gt;&lt;![CDATA[
                      	  Defines the required cardinality of the relationship to the backing services. If not specified, 
                      	  the default-cardinality attribute will apply. A value of '1..N' means that at least one backing 
                      	  service must exist (this is a mandatory service reference. A value of '0..N' indicates that it 
                      	  is acceptable for there to be no backing service (an optional service reference).
                      	]]&gt;&lt;/xsd:documentation&gt;
                      &lt;/xsd:annotation&gt;
                &lt;/xsd:attribute&gt;				
			&lt;/xsd:extension&gt;
		&lt;/xsd:complexContent&gt;
	&lt;/xsd:complexType&gt;
	
	&lt;xsd:complexType name="Tcomparator"&gt;
		&lt;xsd:annotation&gt;
			&lt;xsd:documentation source="java:java.util.Comparator"&gt;&lt;![CDATA[
			  Used to define an inline bean of type Comparator that will be used to sort the matching services.
			]]&gt;&lt;/xsd:documentation&gt;
			&lt;xsd:appinfo&gt;
				&lt;tool:annotation&gt;
					&lt;tool:exports type="java.util.Comparator" /&gt;
  				&lt;/tool:annotation&gt;
			&lt;/xsd:appinfo&gt;
		&lt;/xsd:annotation&gt;
		&lt;xsd:choice&gt;
		   &lt;xsd:element name="natural" type="TnaturalOrdering"/&gt;
     	   &lt;xsd:sequence minOccurs="1" maxOccurs="1"&gt;
        	    &lt;!-- nested bean declaration --&gt;
           		&lt;xsd:any namespace="##other" minOccurs="1" maxOccurs="1" processContents="skip"/&gt;
        	&lt;/xsd:sequence&gt;
        &lt;/xsd:choice&gt;
	&lt;/xsd:complexType&gt;
	
	&lt;xsd:complexType name="TnaturalOrdering"&gt;
		&lt;xsd:attribute name="basis" type="TorderingBasis" use="required"/&gt;
	&lt;/xsd:complexType&gt;
	
	&lt;xsd:simpleType name="TorderingBasis"&gt;
		&lt;xsd:restriction base="xsd:token"&gt;
            &lt;xsd:enumeration value="service"/&gt;
            &lt;xsd:enumeration value="service-reference"/&gt;
        &lt;/xsd:restriction&gt;
	&lt;/xsd:simpleType&gt;
	
	&lt;xsd:simpleType name="TcollectionCardinality"&gt;
        &lt;xsd:restriction base="xsd:token"&gt;
            &lt;xsd:enumeration value="1..N"/&gt;
            &lt;xsd:enumeration value="0..N"/&gt;
        &lt;/xsd:restriction&gt;
   &lt;/xsd:simpleType&gt;
	
    &lt;!-- service --&gt;
    
    &lt;xsd:element name="service" type="Tservice"/&gt;

    &lt;xsd:complexType name="Tservice"&gt;
    	&lt;xsd:annotation&gt;
    		&lt;xsd:documentation source="java:org.springframework.osgi.service.exporter.support.OsgiServiceFactoryBean"&gt;&lt;![CDATA[
    			Exports the reference bean as a service in the OSGi service registry. The bean defined by this element is of 
    			type org.osgi.framework.ServiceRegistration.
    		]]&gt;&lt;/xsd:documentation&gt;
			&lt;xsd:appinfo&gt;
				&lt;tool:annotation&gt;
					&lt;tool:exports type="org.osgi.framework.ServiceRegistration"/&gt;
				&lt;/tool:annotation&gt;
			&lt;/xsd:appinfo&gt;			
    	&lt;/xsd:annotation&gt;
        &lt;xsd:complexContent&gt;
            &lt;xsd:extension base="beans:identifiedType"&gt;
                &lt;xsd:sequence minOccurs="0" maxOccurs="1"&gt;
                    &lt;xsd:element name="interfaces" type="beans:listOrSetType" minOccurs="0"&gt;
                    	&lt;xsd:annotation&gt;
                    		&lt;xsd:documentation&gt;&lt;![CDATA[
                    			The set of service interfaces to advertise in the service registry.
                    		]]&gt;&lt;/xsd:documentation&gt;
                    	&lt;/xsd:annotation&gt;
                    &lt;/xsd:element&gt;
                    &lt;xsd:element name="service-properties" minOccurs="0" type="beans:mapType"&gt;
                       	&lt;xsd:annotation&gt;
                    		&lt;xsd:documentation&gt;&lt;![CDATA[
                    			Defines the service properties.
                    		]]&gt;&lt;/xsd:documentation&gt;
                    	&lt;/xsd:annotation&gt;
                    &lt;/xsd:element&gt;
                    &lt;xsd:element name="registration-listener" type="TserviceRegistrationListener" minOccurs="0" maxOccurs="unbounded"&gt;
                    	&lt;xsd:annotation&gt;
                    		&lt;xsd:documentation&gt;&lt;![CDATA[
                    			Defines a listener that will be notified when this service is registered or unregistered in the
                    			OSGi service registry.
                    		]]&gt;&lt;/xsd:documentation&gt;
                    	&lt;/xsd:annotation&gt;
                    &lt;/xsd:element&gt;
                    
                    &lt;!-- nested bean declaration --&gt;
                    &lt;xsd:any namespace="##other" minOccurs="0" maxOccurs="1" processContents="skip"/&gt;
                &lt;/xsd:sequence&gt;
                &lt;xsd:attribute name="interface" type="xsd:token" use="optional"&gt;
                	&lt;xsd:annotation&gt;
                		&lt;xsd:documentation&gt;&lt;![CDATA[
                			Defines the interface to advertise for this service in the service registry.
                		]]&gt;&lt;/xsd:documentation&gt;
						&lt;xsd:appinfo&gt;
							&lt;tool:annotation&gt;
  								&lt;tool:expected-type type="java.lang.Class" /&gt;
  							&lt;/tool:annotation&gt;
						&lt;/xsd:appinfo&gt;  							
                	&lt;/xsd:annotation&gt;
                &lt;/xsd:attribute&gt;
                &lt;xsd:attribute name="ref" type="xsd:string" use="optional"&gt;
                	&lt;xsd:annotation&gt;
                		&lt;xsd:documentation&gt;&lt;![CDATA[
                			Refers to the named bean to be exported as a service in the service registry.
                		]]&gt;&lt;/xsd:documentation&gt;
                	&lt;/xsd:annotation&gt;
                &lt;/xsd:attribute&gt;
                &lt;xsd:attribute name="depends-on" type="xsd:string" use="optional"&gt;
                	&lt;xsd:annotation&gt;
                		&lt;xsd:documentation&gt;&lt;![CDATA[
                			Used to ensure that the service is not exported to the registry before the named bean
                			has been created. 
                		]]&gt;&lt;/xsd:documentation&gt;
                	&lt;/xsd:annotation&gt;
                &lt;/xsd:attribute&gt;
                &lt;xsd:attribute name="context-class-loader" type="TserviceClassLoaderOptions" default="unmanaged"&gt;
                	&lt;xsd:annotation&gt;
                		&lt;xsd:documentation&gt;&lt;![CDATA[
                			Defines how the context class loader will be managed when an operation is invoked on the 
                			exported service. The default value is 'unmanaged' which means that no management of 
                			the context class loader is attempted. A value of 'service-provider' guarantees that
                			the context class loader will have visibility of all the resources on the class path of 
                			bundle exporting the service.
                		]]&gt;&lt;/xsd:documentation&gt;
                	&lt;/xsd:annotation&gt;
                &lt;/xsd:attribute&gt;
                &lt;xsd:attribute name="auto-export" type="TautoExportModes" default="disabled"&gt;
                	&lt;xsd:annotation&gt;
                		&lt;xsd:documentation&gt;&lt;![CDATA[
                			Enables Spring to automatically manage the set of service interfaces advertised for the
                			service. By default this facility is disabled. A value of 'interfaces' advertises all 
                			of the Java interfaces supported by the exported service. A value of 'class-hierarchy' 
                			advertises all the Java classes in the hierarchy of the exported service. A value of 
                			'all-classes' advertises all Java interfaces and classes. 
                		]]&gt;&lt;/xsd:documentation&gt;
                	&lt;/xsd:annotation&gt;
                &lt;/xsd:attribute&gt;
                &lt;xsd:attribute name="ranking" type="xsd:int" default="0"&gt;
                	&lt;xsd:annotation&gt;
                		&lt;xsd:documentation&gt;&lt;![CDATA[
                			Specify the service ranking to be used when advertising the service.
                		]]&gt;&lt;/xsd:documentation&gt;
                	&lt;/xsd:annotation&gt;
                &lt;/xsd:attribute&gt;
            &lt;/xsd:extension&gt;
        &lt;/xsd:complexContent&gt;
    &lt;/xsd:complexType&gt;

    &lt;xsd:complexType name="TserviceRegistrationListener"&gt;
    	&lt;xsd:annotation&gt;
    		&lt;xsd:documentation&gt;&lt;![CDATA[
    			Defines a listener that will be notified when the bean is registered or unregistered in the OSGi Service Registry. 
    			Use either the 'ref' attribute or a nested bean declaration for the listener bean.
    		]]&gt;&lt;/xsd:documentation&gt;
    	&lt;/xsd:annotation&gt;
        &lt;xsd:sequence minOccurs="0" maxOccurs="1"&gt;
            &lt;!-- nested bean declaration --&gt;
            &lt;xsd:any namespace="##other" minOccurs="1" maxOccurs="1" processContents="skip"/&gt;
        &lt;/xsd:sequence&gt;

        &lt;!-- shortcut for bean references --&gt;
        &lt;xsd:attribute name="ref" type="xsd:string" use="optional"&gt;
        	&lt;xsd:annotation&gt;
        		&lt;xsd:documentation&gt;&lt;![CDATA[
        			Refers by name to the bean that will receive register and unregister events.
        		]]&gt;&lt;/xsd:documentation&gt;
        	&lt;/xsd:annotation&gt;
        &lt;/xsd:attribute&gt;
        &lt;xsd:attribute name="registration-method" type="xsd:token" use="optional"&gt;
        	&lt;xsd:annotation&gt;
        		&lt;xsd:documentation&gt;&lt;![CDATA[
        			The name of the method to be invoked when the service is registered.
        		]]&gt;&lt;/xsd:documentation&gt;
        	&lt;/xsd:annotation&gt;
        &lt;/xsd:attribute&gt;
        &lt;xsd:attribute name="unregistration-method" type="xsd:token" use="optional"&gt;
        	&lt;xsd:annotation&gt;
        		&lt;xsd:documentation&gt;&lt;![CDATA[
        			The name of the method to be invoked when the service is unregistered.
        		]]&gt;&lt;/xsd:documentation&gt;
        	&lt;/xsd:annotation&gt;
        &lt;/xsd:attribute&gt;
    &lt;/xsd:complexType&gt;

    &lt;xsd:simpleType name="TserviceClassLoaderOptions"&gt;
        &lt;xsd:restriction base="xsd:token"&gt;
            &lt;xsd:enumeration value="service-provider"/&gt;
            &lt;xsd:enumeration value="unmanaged"/&gt;
        &lt;/xsd:restriction&gt;
    &lt;/xsd:simpleType&gt;

    &lt;xsd:simpleType name="TautoExportModes"&gt;
        &lt;xsd:restriction base="xsd:token"&gt;
            &lt;xsd:enumeration value="disabled"/&gt;
            &lt;xsd:enumeration value="interfaces"/&gt;
            &lt;xsd:enumeration value="class-hierarchy"/&gt;
            &lt;xsd:enumeration value="all-classes"/&gt;
        &lt;/xsd:restriction&gt;
    &lt;/xsd:simpleType&gt;

    &lt;!-- bundle --&gt;

    &lt;xsd:element name="bundle" type="Tbundle"&gt;
    	&lt;xsd:annotation&gt;
    		&lt;xsd:documentation source="java:org.springframework.osgi.bundle.BundleFactoryBean"&gt;&lt;![CDATA[
    			Defines a bean representing a Bundle object. May be used to drive bean lifecycle transitions.
    		]]&gt;&lt;/xsd:documentation&gt;
			&lt;xsd:appinfo&gt;
				&lt;tool:annotation&gt;
					&lt;tool:exports type="org.osgi.framework.Bundle"/&gt;
				&lt;/tool:annotation&gt;
			&lt;/xsd:appinfo&gt;    		
    	&lt;/xsd:annotation&gt;
    &lt;/xsd:element&gt;

    &lt;xsd:complexType name="Tbundle"&gt;
        &lt;xsd:complexContent&gt;
            &lt;xsd:extension base="beans:identifiedType"&gt;
              	&lt;!-- optional nested bean declaration --&gt;
                &lt;xsd:sequence minOccurs="0" maxOccurs="1"&gt;
		    		&lt;xsd:any namespace="##other" minOccurs="1" maxOccurs="1" processContents="lax"&gt;
            		   	&lt;xsd:annotation&gt;
                    		&lt;xsd:documentation&gt;&lt;![CDATA[
                    			OSGi bundle to work with.
                    		]]&gt;&lt;/xsd:documentation&gt;
							&lt;xsd:appinfo&gt;
								&lt;tool:annotation&gt;
  									&lt;tool:expected-type type="org.osgi.framework.Bundle" /&gt;
  								&lt;/tool:annotation&gt;
							&lt;/xsd:appinfo&gt;  							
                    	&lt;/xsd:annotation&gt;
            		&lt;/xsd:any&gt;
        		&lt;/xsd:sequence&gt;
        		
                &lt;xsd:attribute name="symbolic-name" type="xsd:string" use="optional"&gt;
                	&lt;xsd:annotation&gt;
                		&lt;xsd:documentation&gt;&lt;![CDATA[
                			The bundle symbolic name of the bundle object. Normally used when interacting with an already
                			installed bundle.
                		]]&gt;&lt;/xsd:documentation&gt;
                	&lt;/xsd:annotation&gt;
                &lt;/xsd:attribute&gt;
                &lt;xsd:attribute name="depends-on" type="xsd:string" use="optional"&gt;
                	&lt;xsd:annotation&gt;
                		&lt;xsd:documentation&gt;&lt;![CDATA[
                			Indicates that this bundle object should not be created until the named bean has been created.
                		]]&gt;&lt;/xsd:documentation&gt;
                	&lt;/xsd:annotation&gt;
                &lt;/xsd:attribute&gt;
               
                &lt;xsd:attribute name="location" type="xsd:string" use="optional"&gt;
                	&lt;xsd:annotation&gt;
                		&lt;xsd:documentation&gt;&lt;![CDATA[
                			Location used to install, update or/and identify a bundle.
                		]]&gt;&lt;/xsd:documentation&gt;
                	&lt;/xsd:annotation&gt;
                &lt;/xsd:attribute&gt;
                &lt;xsd:attribute name="action" type="TbundleAction" use="optional"&gt;
                	&lt;xsd:annotation&gt;
                		&lt;xsd:documentation&gt;&lt;![CDATA[
                		Lifecyle action to drive on the bundle. 'start' starts the bundle, installing if necessary.
                		'stop' stops the bundle if it is currently ACTIVE. 'install' installs the bundle if it is 
                		currently uninstalled. 'uninstall' stops the bundle if needed, and then uninstalls it.
                		'update' installs the bundle if needed, and then invokes the Bundle.update() operation.
                		]]&gt;&lt;/xsd:documentation&gt;
                	&lt;/xsd:annotation&gt;
                &lt;/xsd:attribute&gt;
                &lt;xsd:attribute name="destroy-action" type="TbundleAction" use="optional"&gt;
                	&lt;xsd:annotation&gt;
                		&lt;xsd:documentation&gt;&lt;![CDATA[
                		Lifecyle action to drive on the bundle. 'start' starts the bundle, installing if necessary.
                		'stop' stops the bundle if it is currently ACTIVE. 'install' installs the bundle if it is 
                		currently uninstalled. 'uninstall' stops the bundle if needed, and then uninstalls it.
                		'update' installs the bundle if needed, and then invokes the Bundle.update() operation.
                		]]&gt;&lt;/xsd:documentation&gt;
                	&lt;/xsd:annotation&gt;
                &lt;/xsd:attribute&gt;
                &lt;xsd:attribute name="start-level" type="xsd:int" use="optional" default="0"&gt;
                	&lt;xsd:annotation&gt;
                		&lt;xsd:documentation&gt;&lt;![CDATA[
                			Start level to set for the bundle.
                		]]&gt;&lt;/xsd:documentation&gt;
                	&lt;/xsd:annotation&gt;
                &lt;/xsd:attribute&gt;
            &lt;/xsd:extension&gt;
        &lt;/xsd:complexContent&gt;
    &lt;/xsd:complexType&gt;

    &lt;xsd:simpleType name="TbundleAction"&gt;
        &lt;xsd:restriction base="xsd:token"&gt;
            &lt;xsd:enumeration value="start"/&gt;
            &lt;xsd:enumeration value="stop"/&gt;
            &lt;xsd:enumeration value="install"/&gt;
            &lt;xsd:enumeration value="uninstall"/&gt;
            &lt;xsd:enumeration value="update"/&gt;
        &lt;/xsd:restriction&gt;
    &lt;/xsd:simpleType&gt;


&lt;/xsd:schema&gt;
    </pre></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="appendix-ack"></a>Appendix&nbsp;G.&nbsp;Acknowledgments</h2></div></div></div><p>Spring Dynamic Modules would like to thank (in alphabetical order) to :
    Bill Gallagher, Olivier Gruber, Richard S. Hall, BJ Hargrave, Peter Kriens,
    Martin Lippert, Jeff McAffer, Glyn Normington, Gerd Wuetherich 
    for their contributions in the development of this specification.</p></div></div><div class="part" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="resources"></a>Part&nbsp;IV.&nbsp;Other Resources</h1></div></div></div><div class="partintro" lang="en"><div></div><p>
              In addition to this reference documentation, there exist a number of
              other resources that may help you learn how to use OSGi and Spring Dynamic
              Modules. These additional, third-party resources are enumerated in this 
              section.
          </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="links"></a>Chapter&nbsp;8.&nbsp;Useful links</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li><span class="emphasis"><em>Getting Started with OSGi</em></span> - by Neil Bartlett 
	<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://neilbartlett.name/blog/osgi-articles/" target="_top">here</a> and 
	<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.eclipse.org/resources/?author=Neil%20Bartlett" target="_top">here</a>.
	</li><li><span class="emphasis"><em>Equinox Documents</em></span> - 
		<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.eclipse.org/equinox/documents/" target="_top">here</a></li><li><span class="emphasis"><em>Felix-related presentations</em></span> - various 
		<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://felix.apache.org/site/presentations.html" target="_top">presentations</a>
		hosted by Apache Felix project.
	</li><li><span class="emphasis"><em>Launching Spring Dynamic Modules using pax-runner</em></span> - 
		<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://wiki.ops4j.org/confluence/display/ops4j/Pax+Runner+-+Screencast+-+Spring+OSGi" target="_top">
		screencast</a></li><li><span class="emphasis"><em>OSGi Alliance Blog</em></span> - <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.osgi.org/blog/" target="_top">here</a></li><li><span class="emphasis"><em>SpringSource OSGi blog</em></span> - <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://blog.springsource.com/main/osgi" target="_top">here</a></li></ul></div></div></div></div></body></html>